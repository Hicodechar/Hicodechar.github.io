<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-02-17T15:40:33+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">CDZ</title><subtitle>Welcome to cdz's blog. Any questions or suggesions, please contact me.</subtitle><entry><title type="html">MPX</title><link href="http://localhost:4000/tech/2019/02/17/mpx.html" rel="alternate" type="text/html" title="MPX" /><published>2019-02-17T01:33:43+08:00</published><updated>2019-02-17T01:33:43+08:00</updated><id>http://localhost:4000/tech/2019/02/17/mpx</id><content type="html" xml:base="http://localhost:4000/tech/2019/02/17/mpx.html">&lt;p&gt;本文主要简单介绍 MPX&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;一mpx-简介&quot;&gt;（一）、MPX 简介&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Intel Memory Protection Extensions&lt;/code&gt; (Intel &lt;code class=&quot;highlighter-rouge&quot;&gt;MPX&lt;/code&gt;)  首次是在 2013 年提出，并在2015年引入到 Intel 的第六代处理器 Skylake. MPX 的目的是为 C/C++ 加入 bounds check 机制，从而保证内存安全。首先，看一下以下代码片段：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
   &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;// Array of pointers to objs&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// Pointer arithmetic on a&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// Pointer to obj at a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// Pointer to obj.len&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Total length of all objs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上程序分配了一个数组 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[10]&lt;/code&gt; 的指针, 也就是10个指针，每个指针都指向类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; 的对象，然后遍历前 M 个对象，把其中的 len 值相加得到总的len值（3-8行）total 。以上代码对应的 C 语言形式为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：&lt;code class=&quot;highlighter-rouge&quot;&gt;ai&lt;/code&gt; 是表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;指针&lt;/code&gt;，同时需要注意 &lt;code class=&quot;highlighter-rouge&quot;&gt;lenptr&lt;/code&gt; 如何指向对象内部的 len。&lt;/p&gt;

&lt;p&gt;当以上代码应用 &lt;code class=&quot;highlighter-rouge&quot;&gt;MPX&lt;/code&gt; 之后的代码为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndmk&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;79&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// Make bounds [a, a+79]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;bndcl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// Lower-bound check of a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;bndcu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// Upper-bound check of a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;objptr_b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndldx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// Bounds for pointer at a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;bndcl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Lower-bound check of obj.len&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;bndcu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Upper-bound check of obj.len&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先，&lt;code class=&quot;highlighter-rouge&quot;&gt;a[10]&lt;/code&gt; 的界限 bounds 在第2行创建（由于这个数组有10个指针，且每个指针的大小为8 bytes，所以上限为 79），然后在第 8 行读入数组中值之前进行边界检查，2个边界检查的命令插入到 load 之前（第6-7行），从而预防 overflow ，注意：由于我们保护的数据大小为8（因为 ai 中的值是个指针），所以上界检查为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ai+7&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这时指向对象 obj 的指针加载到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt;，那么程序的下一步是要读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj.len&lt;/code&gt; 。根据设计 MPX 也需要保护这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的读写。那么这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的界限怎么得到呢？在 MPX 设计中每个存在内存中的指针都有与之对应的 bounds 存储在一个特定的内存位置（后面会讲到），并且可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndstx&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; 指令来获取。所以当从 &lt;code class=&quot;highlighter-rouge&quot;&gt;ai&lt;/code&gt; 获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的时候， &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的界限也使用指令 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ai&lt;/code&gt; 来获取(第9行). 最后，在读入 len 之前也需要界限检查（第11-12行）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里得到 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的界限是通过  &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr 在内存的地址（如 ai）&lt;/code&gt;，而不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr 所指向的地址（如 objptr 的值）&lt;/code&gt; 来获取的。&lt;/p&gt;

&lt;p&gt;为了实现上述的 MPX 需要在以下各层作出修改：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;hardware level&lt;/code&gt; : 添加一系列 128-bits 寄存器，和相应的指令支持，以及通过指令抛 &lt;code class=&quot;highlighter-rouge&quot;&gt;#BR exception&lt;/code&gt; 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;OS level&lt;/code&gt; : 实现  &lt;code class=&quot;highlighter-rouge&quot;&gt;#BR exception handler&lt;/code&gt; ; 主要是实现两个函数：（1）按需存储界限；（2）当发生界限检查发现出界的情况向用户程序发送相应的信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compiler level&lt;/code&gt; 需要添加 MPX 转换 pass，用于插入 MPX 指令来 create、propagate、store 界限，和界限检查。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文主要翻译介绍 &lt;code class=&quot;highlighter-rouge&quot;&gt;hardware level&lt;/code&gt; 的实现，对于其他层的介绍可以阅读参考链接阅读&lt;a href=&quot;https://intel-mpx.github.io/design/&quot;&gt;原文&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;二-hardware&quot;&gt;（二）、 Hardware&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Intel MPX 提供了 7 个新的指令和一系列 128-bits 寄存器。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Skylake&lt;/code&gt; 架构中提供的 4 个寄存器是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd0-bnd3&lt;/code&gt;；每个寄存器的低 64 位存储的是边界的下界，高64位存储的是边界的上界。&lt;/p&gt;

&lt;p&gt;新添加的指令是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndmk&lt;/code&gt; : 创建新的界限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndcl&lt;/code&gt; : 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPR&lt;/code&gt;(general-purpos register) 中指针的值和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 中的界限的下界进行比较。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndcu&lt;/code&gt; : 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPR&lt;/code&gt;(general-purpos register) 中指针的值和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 中的界限的上界进行比较。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndcn&lt;/code&gt; : 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndcu&lt;/code&gt; 的互补形式，效果一样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndmov&lt;/code&gt; : 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 寄存器中的值从一个寄存器移动到另一个寄存器，并存入到栈上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; : 从 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;ounds &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;ables 中加载界限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndstx&lt;/code&gt; : 存储界限到 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;ounds &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;ables 中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时 MPX 还更改了x86-64 的函数调用部分，把参数中的指针界限存入到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd0-bnd3&lt;/code&gt; , 函数返回前，当返回值为指针，则把该指针的界限保存到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd0&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;对于界限检查使用硬件实现和软件方式相比优势是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;MPX 新引入了寄存器，从而减少 GPR(general-purpos register) 的负担。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于软件实现方案不能更改函数调用，所以只能使用 function copy, 当参数中函数指针的时候，把指针相应的界限加入到参数中，从而使得参数变得太多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;性能问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MPX 有个很好的特性就是向前兼容，MPX 程序能够运行在老的不支持 MPX 的机器上，因为 MPX 指令在老机器上为 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOP&lt;/code&gt; 指令。同时支持 MPX 的机器能够运行之前的老代码，因为：（1）有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;BNDPRESERVE&lt;/code&gt; 位来设置指针没有界限信息；（2）在老代码中，出现对内存中指针的更改的话，那么下一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; 的话会知道这个更改，并把界限设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;INIT&lt;/code&gt; 也就是没有界限限制。所以根据以上两点使得在 create 、altered 指针时都能够得到无界限限制的指针，所以便于解决兼容问题。&lt;/p&gt;

&lt;h4 id=&quot;storing-bounds-in-memory&quot;&gt;Storing bounds in memory&lt;/h4&gt;

&lt;p&gt;由于 MPX 只有 4 个 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 寄存器，这显然是不够的，所以当需要存储的界限超过 4 时需要把界限存储到内存中。一个简单快速的方法为：直接把界限通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndmov&lt;/code&gt; 复制到编译器指定的内存位置 stack。但是，以上方法只能把界限存储到单一的 stack frame 上，如果别的函数还用到这个指针的话将得不到相应的界限。为了解决这个问题，引入了两个新的指令 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndstx&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt;，这两个指令会 store/load 界限到内存，那么存储到内存的什么位置呢？这个位置是根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;指针的位置&lt;/code&gt; 计算出来的（注意：是指针的位置而不是指针的值）。所以不需要额外的信息就可以得到指针对应的界限。&lt;/p&gt;

&lt;p&gt;如何根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;指针的位置&lt;/code&gt; 计算出指针对应的界限呢？&lt;/p&gt;

&lt;p&gt;做法是通过两级地址翻译的过程，其实该做法和页表非常相似。每个指针在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table (BT)&lt;/code&gt; 中都有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt; 与之对应，该  &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt; 的大小为 128-bits 内容为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LBound&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UBound&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pointer&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Preserved&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中， &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt; 是存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table (BT)&lt;/code&gt; 的，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table (BT)&lt;/code&gt; 的基址是存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Directory (BD)&lt;/code&gt; 中的。这和 Paging 非常相似：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt;  $\to$ &lt;code class=&quot;highlighter-rouge&quot;&gt;Page Table Entry&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table&lt;/code&gt;  $\to$ &lt;code class=&quot;highlighter-rouge&quot;&gt;Page Table&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Directory&lt;/code&gt;  $\to$ &lt;code class=&quot;highlighter-rouge&quot;&gt;PageDirectory&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;翻译过程如下图所以：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/image/MPX/mpx.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先，需要找到 BD entry：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;1）把指针的地址中第 20-47 位左移 3 位（因为 BD entry 的大小位 $2^3$ ）来获取  BD entry 在 BD 中的偏移量。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;2）从 &lt;code class=&quot;highlighter-rouge&quot;&gt;BNDCFGx&lt;/code&gt; 寄存器中获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;BD 基址&lt;/code&gt; （其中：&lt;code class=&quot;highlighter-rouge&quot;&gt;BNDCFGU&lt;/code&gt; 对应用户态的，&lt;code class=&quot;highlighter-rouge&quot;&gt;BNDCFGS&lt;/code&gt; 对应内核态）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;3）把基址和偏移量相加从而得到 BD entry。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其次，需要找到 BT entry：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;4）把指针的地址中第 3-19 位左移 5 位（因为 BT entry 的大小位 $2^5$ ）来获取  BT entry 在 BT 中的偏移量。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;5）把上一步获取的 BD entry右移 3 位（用于删除前 3 位包含的 metadata）来获取  BT 基址。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;6）把基址和偏移量相加从而得到 BT entry。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;7）Load BT entry。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：在 BT entry 中存储了指针的值，其用处是每次找到这个 BT entry 后需要把指针值和 BT entry中的指针值进行比较，如果不相等则默认这个指针的界限为 &lt;code class=&quot;highlighter-rouge&quot;&gt;INIT&lt;/code&gt; ，主要用于兼容性考虑。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;三参考&quot;&gt;（三）、参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://intel-mpx.github.io/design/&quot;&gt;https://intel-mpx.github.io/design/&lt;/a&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文主要简单介绍 MPX</summary></entry><entry><title type="html">SSA Form and PHI Nodes</title><link href="http://localhost:4000/llvm/tech/2019/02/14/ssa-form-and-phi-nodes.html" rel="alternate" type="text/html" title="SSA Form and PHI Nodes" /><published>2019-02-14T20:26:29+08:00</published><updated>2019-02-14T20:26:29+08:00</updated><id>http://localhost:4000/llvm/tech/2019/02/14/ssa-form-and-phi-nodes</id><content type="html" xml:base="http://localhost:4000/llvm/tech/2019/02/14/ssa-form-and-phi-nodes.html">&lt;p&gt;本文主要简单介绍 LLVM 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHINode&lt;/code&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;最近接触到追踪一个变量在程序中的使用。当对 LLVM IR 中 instruction 进行分析的时候，遇到类似如下的代码：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;%19&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%entry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%land.rhs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该指令为 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHINode&lt;/code&gt;，为 llvm 中的一个指令类，继承于 &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm::Instruction&lt;/code&gt;，具体继承关系和 llvm 源码见：&lt;a href=&quot;https://llvm.org/doxygen/classllvm_1_1PHINode.html&quot;&gt;PHINode 类&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;一ssa-简介&quot;&gt;（一）、SSA 简介&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
在正式介绍 PHI Nodes 之前首先需要了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSA&lt;/code&gt; ，因为所有的 LLVM IR 指令都是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSA&lt;/code&gt; 形式表示。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;1ssa&quot;&gt;（1）、SSA&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SSA (static single assignment form)&lt;/code&gt; ：&lt;strong&gt;静态一次性赋值&lt;/strong&gt;；意思是说&lt;strong&gt;每个变量（虚拟寄存器）都只能被赋值一次&lt;/strong&gt;；这样做的好处是可以方便优化代码。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nl&quot;&gt;y :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;y :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;x :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;显然，在以上代码中我们能够一眼看出第一行代码是多余的，因为在第三行使用的 $y$ 的值是来自第二行对 $y$ 的赋值，而不是来自第一行对 $y$ 的赋值。而对于程序来说并不能直观的得出第一行是多余的，需要做数据流分析才能判断第一行是多余的。$SSA$ 恰好能够解决该问题，以上代码用 $SSA$ 形式来表示的话：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nl&quot;&gt;y1 :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;y2 :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;x1 :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;很明显，用以上表示方法程序不需要做数据流分析就能够知道第三行使用的 $y$ 是来自第二行的定义。当然，使用 $SSA$ 还能做很多别的优化，我也没有细看，这里就不再赘述了，有兴趣的话可以参考：&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single_assignment_form&quot;&gt;维基百科上的介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;2生成-ssa-形式的指令&quot;&gt;（2）、生成 SSA 形式的指令&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;
我们可以通过探究 $SSA$ 指令的生成知道为什么要引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI Nodes&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;把一个普通程序转化为 $SSA$ 形式，最简单的做法就是把每一次的赋值都赋值给一个新的变量（或者说是同一个变量的不同版本），同时在使用变量的时候，使用能够到达该程序点对应的”版本”。
举个例子，在下图的控制流图中，左边图一是原程序流图，右图为按照上述方法生成的 SSA 形式的程序流图。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;图一：原程序流图&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;图二：SSA 形式流图（中间版本）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/7/73/SSA_example1.1.png&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/f/f7/SSA_example1.2.png&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们可以发现在右图最底下的基本块中，对于 $y$ 的使用可能来自 $y_1$ 也可能来自 $y_2$，取决于程序是从哪条路径到达该程序点的。为了解决该问题，引入了一条新的语句：$\phi$，该语句会生成一个新的 $y$ 的定义 $y_3$，$y_3$ 的值会根据控制流是从哪条路径到达而选择不同的值 $y_1$ 或 $y_2$:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;图三：SSA 形式流图&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/84/SSA_example1.3.png&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上述的 $\phi$ 函数就是我们所要介绍的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI Node&lt;/code&gt;。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
$ y_3 \leftarrow \phi (y_1, y_2) $
&lt;/p&gt;
&lt;p&gt;PHI node 根据控制流是从哪一个 block ( $y_1\leftarrow x_2 * 2$ 或 $y_2\leftarrow x_2 -3$) 到达，来决定使用 $y_1$ 或 $y_2$ 赋值给 $y_3$。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;二phi-nodes-简介&quot;&gt;（二）、PHI Nodes 简介&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
在上一节中我们已经介绍了为什么要引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI Nodes&lt;/code&gt;；本节主要通过一个例子来讲解 PHI Nodes。&lt;/p&gt;

&lt;p&gt;回顾一下 PHI Nodes：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;PHI Nodes 会记录是从哪个 control-flow 过来的，从而使用相应的值（类似多路复用器）。&lt;/li&gt;
    &lt;li&gt;并没有实际实现，只是编译器会保证相应的 virtual registers 映射到了同一个 physical register。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，以下左图为原程序，右图为相应的 control-flow。
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/LLVM/PHINode/phinode_no_ssa.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
当引入 SSA 形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/LLVM/PHINode/phinode_ssa.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
对于一个 PHI node 可以表示为：&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%result = phi i32 [value1, BB label1], [value2, BB label2]&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;当从 label1 所对应的 basic block(BB) 路径到达 PHI node, 则 result 的值为 value1; 同理,当从 label2 所对应的 basic block路径到达 PHI node, 则 result 的值为 value2。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;三参考链接&quot;&gt;（三）、参考链接&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;http://www.llvmpy.org/llvmpy-doc/dev/doc/llvm_concepts.html#ssa-form-and-phi-nodes&quot;&gt;http://www.llvmpy.org/llvmpy-doc/dev/doc/llvm_concepts.html#ssa-form-and-phi-nodes&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single_assignment_form&quot;&gt;https://en.wikipedia.org/wiki/Static_single_assignment_form&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://cs.uni-paderborn.de/fileadmin/informatik/fg/hit/teaching/SS2017/HWSW-Codesign/02-Compiler-LLVM.pdf&quot;&gt;https://cs.uni-paderborn.de/fileadmin/informatik/fg/hit/teaching/SS2017/HWSW-Codesign/02-Compiler-LLVM.pdf&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://llvm.org/doxygen/classllvm_1_1PHINode.html&quot;&gt;https://llvm.org/doxygen/classllvm_1_1PHINode.html&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文主要简单介绍 LLVM 中的 PHINode。</summary></entry><entry><title type="html">Test for blogging</title><link href="http://localhost:4000/jekyll/tech/2019/02/07/test-for-blogging.html" rel="alternate" type="text/html" title="Test for blogging" /><published>2019-02-07T12:55:13+08:00</published><updated>2019-02-07T12:55:13+08:00</updated><id>http://localhost:4000/jekyll/tech/2019/02/07/test-for-blogging</id><content type="html" xml:base="http://localhost:4000/jekyll/tech/2019/02/07/test-for-blogging.html">&lt;p&gt;该文用于说明写 blog 的一些格式要求。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建-blog&quot;&gt;新建 blog&lt;/h3&gt;

&lt;p&gt;当需要创建一个新的 blog 时(假设名字为：Test for blogging), 在 blog 的主目录中输入以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopress new post Test for blogging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该命令会在文件夹 &lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt; 中生成文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;2019-02-07-test-for-blogging.markdown&lt;/code&gt;, 文件名前面的时间是自动添加的，编辑该文件为以下格式：&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;layout: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;title: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Test for blogging&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;date: &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2019&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;07&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;08&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;categories: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Jekyll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Tech&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;author: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cdz&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;excerpt_separator: &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;这里编写&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blog&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;正文。中间可以用&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;分割。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;: 表示该 blog 属于哪个 layout，不同的 layout 会有不同的显示，具体显示的格式规定在文件夹 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt; 中，当为 &lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt; 时表示按照 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts/post.html&lt;/code&gt; 的格式显示。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;: 表示该 blog 的生成时间，是自动生成的。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;categories&lt;/code&gt;: 表示该 blog 属于那一类，可以自己定义，当属于多个类的时候需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;[category1, category2 ]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;author&lt;/code&gt;: 表示该 blog 的博主。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;excerpt_separator: &amp;lt;!--more--&amp;gt;&lt;/code&gt;: 表示在该 blog 中使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 分割， &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 的前一半内容会显示在home中的预览中，后一半只有点进博客才能看到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里是插入网址的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 格式为：[文中显示内容][网页地址记号]
// 在文本的最后：[网页地址记号]：网页地址
[CDZ's Blog][cdz-blog]

[cdz-blog]: https://blog.dianzhangchen.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;预览-blog&quot;&gt;预览 blog&lt;/h3&gt;

&lt;p&gt;在主目录中输入：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build
jekyll serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时候在浏览器中输入：&lt;a href=&quot;http://localhost:4000/&quot;&gt;http://localhost:4000/&lt;/a&gt; 就可以去看效果。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;部署-blog-到网站&quot;&gt;部署 blog 到网站&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopress deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写-markdown-的一些技巧&quot;&gt;编写 markdown 的一些技巧&lt;/h3&gt;

&lt;h4 id=&quot;1插入空行&quot;&gt;(1)、插入空行&lt;/h4&gt;

&lt;p&gt;插入空行使用 html 的语法，只需要在相应的位置插入 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br/&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;2插入图片&quot;&gt;(2)、插入图片&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![image-title-here](/path/to/image.jpg){:class=&quot;img-responsive&quot;}

// 或者按照以下方法，使用 html 语法, 可以调节图片的大小
&amp;lt;p&amp;gt;&amp;lt;img src=&quot;/image/DongBei/barbecue.jpg&quot; width=&quot;500&quot;&amp;gt;&amp;lt;/p&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一种方法效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/test/icon.ico&quot; alt=&quot;test_image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二种方法效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/test/icon.ico&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">该文用于说明写 blog 的一些格式要求。</summary></entry><entry><title type="html">在东北</title><link href="http://localhost:4000/life/travel/2019/02/07/md.html" rel="alternate" type="text/html" title="在东北" /><published>2019-02-07T10:26:57+08:00</published><updated>2019-02-07T10:26:57+08:00</updated><id>http://localhost:4000/life/travel/2019/02/07/md</id><content type="html" xml:base="http://localhost:4000/life/travel/2019/02/07/md.html">&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/image/DongBei/snow_train.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;扬帆&quot;&gt;扬帆&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;今年上海的雪下得吊人胃口，虽说来的早，可落地即化，未免有点失望。&lt;br /&gt;
对于南方人，能在冬天看看雪，吃点冰块就很幸福了。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;要不要一起去东北玩？ &lt;br /&gt;
妥！！！&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;出发前对于东北充满好奇。&lt;br /&gt;
零下20度是什么概念？&lt;br /&gt;
一出山海关，都是赵本山？&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;接着就是各种准备。加厚棉袜，手套，雪地靴，雷锋帽，暖宝宝。&lt;br /&gt;
出于对零下20度的敬畏，线上线下一顿忙活。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;奉天&quot;&gt;奉天&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
到沈阳，住进宾馆，已是傍晚。&lt;br /&gt;
随后就在中街溜达，刚开始去了个假的中街。&lt;br /&gt;
一行人就感叹，怎么着也是个省会城市的最有名的步行街，怎么能这么小？&lt;br /&gt;
失望的找地铁站回家途中，走到了真正的中街，豁然开朗。&lt;br /&gt;
它拥有了一个步行街该有的繁华，绚丽。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不得不说，东北的暖气是神一般的存在。&lt;br /&gt;
当晚在宾馆，热得一宿没睡，就在思考一个问题，为啥暖气不设计为可以选择性开关？&lt;br /&gt;
想来想去也没想到好的解决办法。&lt;br /&gt;
如果给用户可以关闭暖气的开关的话，那么暖气就应该走另外的辅助通道，而对于暖气供应公司来说，并没有减少能耗，还不如不让关闭，还能都收取费用。&lt;br /&gt;
那么能不能重新设计暖气通道，使得暖气不需要辅助通道的情况下设计为可以选择性关闭？而这又是一个图连通问题，我们不确定哪些用户会关闭暖气，有可能一些用户关闭暖气后，导致图不连通，使得某些开暖气的用户，也无法开启暖气。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;第二天就去了沈阳冰雪大世界，各种游乐项目：冰上碰碰车，雪摩托，雪地飞狐。&lt;br /&gt;
最刺激的还是冰滑道：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/shenyang_ski.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;泡澡&quot;&gt;泡澡&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;刚开始提出去泡澡计划，我想都没想就拒绝了。&lt;br /&gt;
之后被各种安利，想想东北特色的洗澡文化，来都来了，不体验一把还是有点遗憾的。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;这边泡澡基本流程就是：冲、泡、搓、蒸、冲。&lt;br /&gt;
搓澡的时候会有各种选择，有红酒搓，醋搓；红酒搓听起来就x格高，自然就选了这个。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在一个类似火车卧铺的床位上加上一层一次性桌布，往上一躺。&lt;br /&gt;
搓澡师当面开封一个新的搓澡巾, 然后就卡卡搓上了。&lt;br /&gt;
变搓边唠嗑，东北话自带幽默属性。&lt;br /&gt;
闭眼，细听，完全认同了东北的搓澡文化。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;想体验东北文化，就得整全套的。&lt;br /&gt;
搓澡之后的烧烤是必须的，东北澡堂周边必有烧烤店。&lt;br /&gt;
几盘烧烤，一瓶啤酒，甚是满足。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/DongBei/barbecue.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;哈尔滨&quot;&gt;哈尔滨&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;哈尔滨就更冷了，拿手机拍照都需要很大的勇气。&lt;br /&gt;
一是，拍照需要摘下手套，又冷又麻烦。&lt;br /&gt;
再者，手机用电很快，且容易冻关机。&lt;br /&gt;
在风大的地方，很多人是倒退走路的：&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/walk_backward.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
在这可以看到浓郁俄罗斯风情的中央大街，随处可听到 “喀秋莎”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/central_street.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
在中央大街附近还有索菲亚大教堂，是一个拜占庭风格的教堂，据说是沙俄第四步兵师修建中东铁路时修建的一座随军教堂。&lt;br /&gt;
夜晚的教堂气宇轩昂。&lt;br /&gt;
同行的一小伙，硬是拿着 GoPro 绕着教堂跑了一圈。&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/church.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;滑雪&quot;&gt;滑雪&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;早上5点多起来坐车去，亚布力滑雪场。&lt;br /&gt;
在中途休息站能看到很有东北特色的小贩。&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/shop.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;滑雪之前还是被忽悠加了一些别的项目，马拉犁、冰滑道、等一些热门娱乐。&lt;br /&gt;
马拉着一车人，在雪地里“飞驰”。&lt;br /&gt;
同车的一大叔开玩笑道：“这马不给力啊，别弄的我们都得下去推车了”。&amp;gt;_&amp;lt;||| &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/malali2.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;也终于到了滑雪的时候。&lt;br /&gt;
曾听说滑雪是白色鸦片，第一次接触滑雪的人，要么从此别过，要么就沾上这个“鸦片”。&lt;br /&gt;
我们滑雪前都定了一个小目标：能够独立缓慢滑行。&lt;br /&gt;
由于我们都有穷病就没有请教练 &amp;gt;_&amp;lt;|||&lt;br /&gt;
刚开始的时候，五米一小摔倒，十米一大摔。&lt;br /&gt;
幸得滑雪场旁边一大爷给我指点，后面摔倒明显减少，就算摔也比之前摔的有尊严一点。&lt;br /&gt;
我感觉滑雪和开车也有相似之处，滑的时候不要盯着脚下，要看前方。&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/ski2.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;松花江&quot;&gt;松花江&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;松花江上结了一层厚冰，上面堆满了雪人，这得有多少人对雪爱的深沉&lt;br /&gt;
我们决定冰面上横跨松花江。&lt;br /&gt;
一行人，围巾遮面，低头避风就缓慢出发了。&lt;br /&gt;
走到松花江中间，环顾四周，突感大自然的神奇，一条活动的江水居然能够结冰，且如此结实。&lt;br /&gt;
由于不敢和寒风正面刚，本来应该垂直跨过松花江，硬生生走出了一条大斜线。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/DongBei/snow_man.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;吃&quot;&gt;吃&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在东北吃的最感人的就属冰糖葫芦了，五块钱一串，冰冰的、酸酸的、甜甜的，甚是可口。&lt;br /&gt;
这让我想起霸王别姬中的桥段，一小孩在自杀之前最后的愿望就是吃冰糖葫芦。&lt;br /&gt;
回上海之前，还特意早起去马迭尔买了几串冰糖葫芦带回来。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;其它的特色食物就是：红菜汤，锅包肉，老太太烧烤，烤冷面，秋林红肠；除了老太太烧烤有点失望外，其余都还算满意。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;后面，还特意去了趟哈尔滨工业大学，感受一波北方大学的建筑风格。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;“世界不是苟且，世界是远方，行万里路才能回到内心深处；未来不是岁数，未来是谜雾，读万卷书才能看清皓月繁星。” &lt;br /&gt;
好好学习，好好工作，赚够旅游的盘缠。&lt;br /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html"></summary></entry></feed>