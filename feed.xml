<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="blog.dianzhangchen.com/feed.xml" rel="self" type="application/atom+xml" /><link href="blog.dianzhangchen.com/" rel="alternate" type="text/html" /><updated>2019-04-11T18:24:59+08:00</updated><id>blog.dianzhangchen.com/feed.xml</id><title type="html">CDZ</title><subtitle>Welcome to cdz's blog. Any questions or suggesions, please contact me.</subtitle><entry><title type="html">Graph Processing</title><link href="blog.dianzhangchen.com/%5Btech/graph/distributed_system%5D/2019/04/11/graph-processing.html" rel="alternate" type="text/html" title="Graph Processing" /><published>2019-04-11T16:42:14+08:00</published><updated>2019-04-11T16:42:14+08:00</updated><id>blog.dianzhangchen.com/%5Btech/graph/distributed_system%5D/2019/04/11/graph-processing</id><content type="html" xml:base="blog.dianzhangchen.com/%5Btech/graph/distributed_system%5D/2019/04/11/graph-processing.html">&lt;p&gt;本文主要简单介绍一些主流的图处理算法&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;一基础知识&quot;&gt;（一）、基础知识&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1图的切分方式&quot;&gt;1、图的切分方式&lt;/h3&gt;
&lt;p&gt;图的切分方式可以分为两种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Edge-cut 边分割&lt;/li&gt;
  &lt;li&gt;Vertex-cut 顶点分割&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/1_edge_cut_vertex_cut.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;11edge-cut&quot;&gt;1.1、Edge-cut&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/2_1edge_cut.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;边分割的话，会把各个点分到不同的机器上，当遇到两个机器上的点有边时，则把边切开，并在两个机器上生成&lt;code class=&quot;highlighter-rouge&quot;&gt;ghost&lt;/code&gt;虚拟顶点；如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/2_2edge_cut.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;该方法的缺点是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;被分割的边，在各个机器上都有一份边，造成边的数量剧增。当边的数量本来就多的话，造成的overhead更大。&lt;/li&gt;
  &lt;li&gt;当 master 节点发生更改时，需要同步给其 ghost 节点，造成网络开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前两种流行的图处理框架：&lt;code class=&quot;highlighter-rouge&quot;&gt;GraphLab&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Pregel&lt;/code&gt; 用的都是&lt;code class=&quot;highlighter-rouge&quot;&gt;Edge-cut&lt;/code&gt;。保证节点均匀的分布在整个集群中间，边被切分成双份分散在整个集群中间。&lt;/p&gt;

&lt;h4 id=&quot;12vertex-cut&quot;&gt;1.2、Vertex-cut&lt;/h4&gt;

&lt;p&gt;引入 Vertex-cut 的目的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;减少通信开销&lt;/li&gt;
  &lt;li&gt;权衡图计算和图存储开销&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于边的数量很多的节点，如果使用 Edge-cut 的话，会使得相应的被切割的边数量变多；且该点对应的 ghost 顶点也很多，所以当需要通信的话，造成的通信开销也变大。&lt;/p&gt;

&lt;p&gt;所以提出了&lt;code class=&quot;highlighter-rouge&quot;&gt;Vertex-cut&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/3_vertex_cut.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;把 High-degree 的顶点进行&lt;code class=&quot;highlighter-rouge&quot;&gt;顶点分割&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这样做的好处是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;图中的&lt;code class=&quot;highlighter-rouge&quot;&gt;边的总数量不变&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;边被均匀的分布到不同的机器上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前两种流行的图处理框架：&lt;code class=&quot;highlighter-rouge&quot;&gt;PowerGraph&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;GraphX&lt;/code&gt; 用的都是&lt;code class=&quot;highlighter-rouge&quot;&gt;Vertex-cut&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2同步计算和异步计算&quot;&gt;2、同步计算和异步计算&lt;/h3&gt;

&lt;h4 id=&quot;21-同步计算&quot;&gt;2.1 同步计算&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/4_synchronous.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;当所有顶点都计算完之后，才能开始下一轮迭代计算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Stragglers(木桶的短板效应)&lt;/code&gt;；当某个顶点计算很慢时，所有别的顶点需要去等待它。
目前： &lt;code class=&quot;highlighter-rouge&quot;&gt;Pregel&lt;/code&gt; 用的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;同步计算&lt;/code&gt;的方式。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;22-异步计算&quot;&gt;2.2 异步计算&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/5_asynchronous.png&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;异步计算允许一些不造成冲突的顶点同时去更新。不是等所有顶点都完成了一次迭代之后才开始下一轮迭代；而是，只要不冲突的顶点就可以继续执行下去。
&lt;strong&gt;缺点：&lt;/strong&gt;为了避免冲突，需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;锁&lt;/code&gt;；而大量的锁会引起性能下降。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;一pregel&quot;&gt;（一）、Pregel&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;该算法是 Google 2010 年提出的图计算的算法。&lt;/p&gt;

&lt;p&gt;对图进行&lt;code class=&quot;highlighter-rouge&quot;&gt;edge-cut&lt;/code&gt;；是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;同步&lt;/code&gt;计算的方法。&lt;/p&gt;

&lt;p&gt;该算法以&lt;code class=&quot;highlighter-rouge&quot;&gt;Bulk Synchronous Parallel(BSP) 整体同步并行计算模型&lt;/code&gt; 为计算模型；
在分布式下面，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;message-passing(消息传递)&lt;/code&gt;在各个顶点之间传递消息；并且是&lt;code class=&quot;highlighter-rouge&quot;&gt;shared-nothing&lt;/code&gt;，也就是说对某个顶点的计算，其所需要的资源都在该顶点所在的机器上面。&lt;/p&gt;

&lt;p&gt;编程思想是：&lt;code class=&quot;highlighter-rouge&quot;&gt;Think like a vertex&lt;/code&gt;：每一个顶点去跑一个算法，然后并行的去在不同的顶点上运行算法。&lt;/p&gt;

&lt;p&gt;计算步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;收取邻接顶点发来的 messages&lt;/li&gt;
  &lt;li&gt;执行该点上的算法&lt;/li&gt;
  &lt;li&gt;更新该点的值&lt;/li&gt;
  &lt;li&gt;发出 message 给邻接点，激活邻接点重新计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/5_pregel.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;strong&gt;把计算和通信分离&lt;/strong&gt;；当所有顶点计算完之后，再统一进行消息传递；消息传递完之后，再统一下一次迭代的重新计算。直到收敛或者迭代到一定数量，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;同步计算&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;二graphlab&quot;&gt;（二）、GraphLab&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;strong&gt;认为 Pregel 这种同步计算的方式太慢&lt;/strong&gt;，特别是对于稀疏图的计算，每次迭代中计算的点的数量很少，且存在&lt;code class=&quot;highlighter-rouge&quot;&gt;木桶短板效应&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以&lt;strong&gt;主要思想&lt;/strong&gt;是：提出&lt;code class=&quot;highlighter-rouge&quot;&gt;异步计算&lt;/code&gt;的方法。&lt;/p&gt;

&lt;p&gt;首先，也需要把图进行划分，划分到不同的机器上；使用的划分方式是：&lt;code class=&quot;highlighter-rouge&quot;&gt;Edge-cut&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当要更新某个顶点时，&lt;code class=&quot;highlighter-rouge&quot;&gt;主动(pull)&lt;/code&gt;的向邻接顶点获取信息。注意这里和 Pregel 的区别，Pregel 使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;被动(push)&lt;/code&gt;的从邻接顶点收取消息。&lt;/p&gt;

&lt;p&gt;那么主动和被动有什么本质的区别吗？&lt;/p&gt;

&lt;p&gt;有，当主动 pull 的话，此时的邻接顶点可以是在  Inactive(空闲) 状态，也就是可以睡觉；而 push 模式的话，邻接顶点必须是 active 状态给你发送消息。&lt;/p&gt;

&lt;p&gt;计算步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从邻接顶点获取信息&lt;/li&gt;
  &lt;li&gt;更细顶点数据&lt;/li&gt;
  &lt;li&gt;如果需要，去叫醒邻接顶点开始计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这个算法中，并不是所有顶点同时收敛；而是动态的有些顶点先收敛，之后其他顶点开始慢慢收敛。&lt;/p&gt;

&lt;p&gt;那么，如何异步调度哪些顶点开始计算呢？&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Round Robin&lt;/li&gt;
  &lt;li&gt;FIFO&lt;/li&gt;
  &lt;li&gt;Priority&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;异步计算的缺点&lt;/code&gt;：当相邻两个顶点同时计算的话，会发生冲突，你拿邻接点开始计算，邻接点也拿你的数据开始计算，所以会造成 consistency 问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/6_graphlab.png&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;简而言之：&lt;strong&gt;用锁&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;三powergraph&quot;&gt;（三）、PowerGraph&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要想法&lt;/strong&gt;：对于 Pregel 和 GraphLab 都是基于Local(本地计算)，也就是当计算某个顶点的时候，其所需要的所有信息都在该本地机器上。但是，由于为了达到本地计算，会在每条分割边上产生一个 ghost 顶点；且&lt;strong&gt;这些 ghost 顶点之间需要同步&lt;/strong&gt;。当某个顶点的边的数量很多时，产生的ghost也变多（每分割一条边就会产生一个ghost）；所以当这个顶点更新时，需要通知所有的ghost，该操作会带来很大性能开销。&lt;/p&gt;

&lt;p&gt;造成以上问题的主要原因：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;edge-cut&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PowerGraph 思路&lt;/code&gt;：采用 &lt;code class=&quot;highlighter-rouge&quot;&gt;vertex-cut&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/6_powergraph.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;然后，计算的时候：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个机器&lt;code class=&quot;highlighter-rouge&quot;&gt;并行&lt;/code&gt;地计算自己的本地sum&lt;/li&gt;
  &lt;li&gt;最后整合到 master 主机上&lt;/li&gt;
  &lt;li&gt;master 主机更新数值之后，同步给告诉 mirror 节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/6_3powergraph.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
由于 PowerGraph 只要同步一个点的节点信息，所以可以&lt;code class=&quot;highlighter-rouge&quot;&gt;减少通信信息&lt;/code&gt;。同时对于边的数量非常大的顶点，可以把对于&lt;code class=&quot;highlighter-rouge&quot;&gt;该顶点&lt;/code&gt;的计算&lt;code class=&quot;highlighter-rouge&quot;&gt;并行&lt;/code&gt;到很多机器上运行。从而可以提高并行度。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;四powerlyra&quot;&gt;（四）、PowerLyra&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要想法&lt;/strong&gt;：由于之前的工作都是使用：&lt;strong&gt;one size fits all&lt;/strong&gt; 的想法；要不都是使用 vertex-cut 要不都使用 edge-cut。
这样做会带来问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当边的数量很多，但是使用 edge-cut 的话：
    &lt;ul&gt;
      &lt;li&gt;很大的竞争&lt;/li&gt;
      &lt;li&gt;很大的通信开销&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/7_1powerlyra.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当边的数量很少，但是使用 vertex-cut 的话：
    &lt;ul&gt;
      &lt;li&gt;没必要的同步操作；因为把一个顶点的计算，分布到多个机器上计算，然后整合。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/7_2powerlyra.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;主要思路&lt;/code&gt;：对于不同的顶点，动态采用不同的图分割方式和计算方式。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于边数很多的顶点，采用类似 vertex-cut 的切分方式&lt;/li&gt;
  &lt;li&gt;对于边数很少的顶点，采用类似 edge-cut 的切分方式&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;五graphchi&quot;&gt;（五）、GraphChi&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;单机下的图计算。&lt;/p&gt;

&lt;p&gt;对于一个很大的图一般是在内存中存不下的；所以一般都是存储在 disk 上，但是存储在 disk 上的话，会带来一些问题。比如读取数据的时候是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Random Access 的，所以读取数据很慢&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;想法：&lt;/code&gt; 如何更改图的数据结构，使得读取数据的时候能够达到好的性能，也就是&lt;strong&gt;相关的数据尽量在一起&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;做法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;把图分割成很多 sharded，使得每个 shared 能够一次性被加载到内存中&lt;/li&gt;
  &lt;li&gt;边的终节点相同的顶点分配到同一个 shared 中&lt;/li&gt;
  &lt;li&gt;对于每个shared中，按照初边序号进行排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/8_graphchi.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;按照以上划分的话：当我需要读取与顶点1和顶点2有关的数据的话，只要把 shard 1 中的顶点全部读取，然后看其余的shard，找到src为1或2的信息；由于每个shard中按照 src 排序了，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;每个 shard 中需要读取的数据都在一起&lt;/code&gt;，减少 Random Access 的开销。&lt;/p&gt;

&lt;p&gt;对读取与顶点1和顶点2有关的数据的话，只要读取以上黄色的区域就可以了。&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文主要简单介绍一些主流的图处理算法</summary></entry><entry><title type="html">MPX</title><link href="blog.dianzhangchen.com/tech/2019/02/17/mpx.html" rel="alternate" type="text/html" title="MPX" /><published>2019-02-17T01:33:43+08:00</published><updated>2019-02-17T01:33:43+08:00</updated><id>blog.dianzhangchen.com/tech/2019/02/17/mpx</id><content type="html" xml:base="blog.dianzhangchen.com/tech/2019/02/17/mpx.html">&lt;p&gt;本文主要简单介绍 MPX&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;一mpx-简介&quot;&gt;（一）、MPX 简介&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Intel Memory Protection Extensions&lt;/code&gt; (Intel &lt;code class=&quot;highlighter-rouge&quot;&gt;MPX&lt;/code&gt;)  首次是在 2013 年提出，并在2015年引入到 Intel 的第六代处理器 Skylake. MPX 的目的是为 C/C++ 加入 bounds check 机制，从而保证内存安全。首先，看一下以下代码片段：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
   &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;// Array of pointers to objs&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// Pointer arithmetic on a&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// Pointer to obj at a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// Pointer to obj.len&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Total length of all objs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上程序分配了一个数组 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[10]&lt;/code&gt; 的指针, 也就是10个指针，每个指针都指向类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; 的对象，然后遍历前 M 个对象，把其中的 len 值相加得到总的len值（3-8行）total 。以上代码对应的 C 语言形式为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：&lt;code class=&quot;highlighter-rouge&quot;&gt;ai&lt;/code&gt; 是表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;指针&lt;/code&gt;，同时需要注意 &lt;code class=&quot;highlighter-rouge&quot;&gt;lenptr&lt;/code&gt; 如何指向对象内部的 len。&lt;/p&gt;

&lt;p&gt;当以上代码应用 &lt;code class=&quot;highlighter-rouge&quot;&gt;MPX&lt;/code&gt; 之后的代码为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndmk&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;79&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// Make bounds [a, a+79]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;bndcl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// Lower-bound check of a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;bndcu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// Upper-bound check of a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;objptr_b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndldx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// Bounds for pointer at a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;bndcl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Lower-bound check of obj.len&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;bndcu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Upper-bound check of obj.len&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先，&lt;code class=&quot;highlighter-rouge&quot;&gt;a[10]&lt;/code&gt; 的界限 bounds 在第2行创建（由于这个数组有10个指针，且每个指针的大小为8 bytes，所以上限为 79），然后在第 8 行读入数组中值之前进行边界检查，2个边界检查的命令插入到 load 之前（第6-7行），从而预防 overflow ，注意：由于我们保护的数据大小为8（因为 ai 中的值是个指针），所以上界检查为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ai+7&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这时指向对象 obj 的指针加载到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt;，那么程序的下一步是要读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj.len&lt;/code&gt; 。根据设计 MPX 也需要保护这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的读写。那么这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的界限怎么得到呢？在 MPX 设计中每个存在内存中的指针都有与之对应的 bounds 存储在一个特定的内存位置（后面会讲到），并且可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndstx&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; 指令来获取。所以当从 &lt;code class=&quot;highlighter-rouge&quot;&gt;ai&lt;/code&gt; 获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的时候， &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的界限也使用指令 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ai&lt;/code&gt; 来获取(第9行). 最后，在读入 len 之前也需要界限检查（第11-12行）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里得到 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的界限是通过  &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr 在内存的地址（如 ai）&lt;/code&gt;，而不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr 所指向的地址（如 objptr 的值）&lt;/code&gt; 来获取的。&lt;/p&gt;

&lt;p&gt;为了实现上述的 MPX 需要在以下各层作出修改：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;hardware level&lt;/code&gt; : 添加一系列 128-bits 寄存器，和相应的指令支持，以及通过指令抛 &lt;code class=&quot;highlighter-rouge&quot;&gt;#BR exception&lt;/code&gt; 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;OS level&lt;/code&gt; : 实现  &lt;code class=&quot;highlighter-rouge&quot;&gt;#BR exception handler&lt;/code&gt; ; 主要是实现两个函数：（1）按需存储界限；（2）当发生界限检查发现出界的情况向用户程序发送相应的信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compiler level&lt;/code&gt; 需要添加 MPX 转换 pass，用于插入 MPX 指令来 create、propagate、store 界限，和界限检查。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文主要翻译介绍 &lt;code class=&quot;highlighter-rouge&quot;&gt;hardware level&lt;/code&gt; 的实现，对于其他层的介绍可以阅读参考链接阅读&lt;a href=&quot;https://intel-mpx.github.io/design/&quot;&gt;原文&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;二-hardware&quot;&gt;（二）、 Hardware&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Intel MPX 提供了 7 个新的指令和一系列 128-bits 寄存器。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Skylake&lt;/code&gt; 架构中提供的 4 个寄存器是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd0-bnd3&lt;/code&gt;；每个寄存器的低 64 位存储的是边界的下界，高64位存储的是边界的上界。&lt;/p&gt;

&lt;p&gt;新添加的指令是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndmk&lt;/code&gt; : 创建新的界限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndcl&lt;/code&gt; : 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPR&lt;/code&gt;(general-purpos register) 中指针的值和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 中的界限的下界进行比较。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndcu&lt;/code&gt; : 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPR&lt;/code&gt;(general-purpos register) 中指针的值和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 中的界限的上界进行比较。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndcn&lt;/code&gt; : 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndcu&lt;/code&gt; 的互补形式，效果一样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndmov&lt;/code&gt; : 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 寄存器中的值从一个寄存器移动到另一个寄存器，并存入到栈上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; : 从 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;ounds &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;ables 中加载界限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndstx&lt;/code&gt; : 存储界限到 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;ounds &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;ables 中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时 MPX 还更改了x86-64 的函数调用部分，把参数中的指针界限存入到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd0-bnd3&lt;/code&gt; , 函数返回前，当返回值为指针，则把该指针的界限保存到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd0&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;对于界限检查使用硬件实现和软件方式相比优势是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;MPX 新引入了寄存器，从而减少 GPR(general-purpos register) 的负担。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于软件实现方案不能更改函数调用，所以只能使用 function copy, 当参数中函数指针的时候，把指针相应的界限加入到参数中，从而使得参数变得太多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;性能问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MPX 有个很好的特性就是向前兼容，MPX 程序能够运行在老的不支持 MPX 的机器上，因为 MPX 指令在老机器上为 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOP&lt;/code&gt; 指令。同时支持 MPX 的机器能够运行之前的老代码，因为：（1）有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;BNDPRESERVE&lt;/code&gt; 位来设置指针没有界限信息；（2）在老代码中，出现对内存中指针的更改的话，那么下一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; 的话会知道这个更改，并把界限设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;INIT&lt;/code&gt; 也就是没有界限限制。所以根据以上两点使得在 create 、altered 指针时都能够得到无界限限制的指针，所以便于解决兼容问题。&lt;/p&gt;

&lt;h4 id=&quot;storing-bounds-in-memory&quot;&gt;Storing bounds in memory&lt;/h4&gt;

&lt;p&gt;由于 MPX 只有 4 个 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 寄存器，这显然是不够的，所以当需要存储的界限超过 4 时需要把界限存储到内存中。一个简单快速的方法为：直接把界限通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndmov&lt;/code&gt; 复制到编译器指定的内存位置 stack。但是，以上方法只能把界限存储到单一的 stack frame 上，如果别的函数还用到这个指针的话将得不到相应的界限。为了解决这个问题，引入了两个新的指令 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndstx&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt;，这两个指令会 store/load 界限到内存，那么存储到内存的什么位置呢？这个位置是根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;指针的位置&lt;/code&gt; 计算出来的（注意：是指针的位置而不是指针的值）。所以不需要额外的信息就可以得到指针对应的界限。&lt;/p&gt;

&lt;p&gt;如何根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;指针的位置&lt;/code&gt; 计算出指针对应的界限呢？&lt;/p&gt;

&lt;p&gt;做法是通过两级地址翻译的过程，其实该做法和页表非常相似。每个指针在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table (BT)&lt;/code&gt; 中都有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt; 与之对应，该  &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt; 的大小为 128-bits 内容为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LBound&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UBound&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pointer&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Preserved&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中， &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt; 是存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table (BT)&lt;/code&gt; 的，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table (BT)&lt;/code&gt; 的基址是存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Directory (BD)&lt;/code&gt; 中的。这和 Paging 非常相似：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt;  $\to$ &lt;code class=&quot;highlighter-rouge&quot;&gt;Page Table Entry&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table&lt;/code&gt;  $\to$ &lt;code class=&quot;highlighter-rouge&quot;&gt;Page Table&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Directory&lt;/code&gt;  $\to$ &lt;code class=&quot;highlighter-rouge&quot;&gt;PageDirectory&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;翻译过程如下图所以：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/image/MPX/mpx.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先，需要找到 BD entry：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;1）把指针的地址中第 20-47 位左移 3 位（因为 BD entry 的大小位 $2^3$ ）来获取  BD entry 在 BD 中的偏移量。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;2）从 &lt;code class=&quot;highlighter-rouge&quot;&gt;BNDCFGx&lt;/code&gt; 寄存器中获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;BD 基址&lt;/code&gt; （其中：&lt;code class=&quot;highlighter-rouge&quot;&gt;BNDCFGU&lt;/code&gt; 对应用户态的，&lt;code class=&quot;highlighter-rouge&quot;&gt;BNDCFGS&lt;/code&gt; 对应内核态）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;3）把基址和偏移量相加从而得到 BD entry。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其次，需要找到 BT entry：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;4）把指针的地址中第 3-19 位左移 5 位（因为 BT entry 的大小位 $2^5$ ）来获取  BT entry 在 BT 中的偏移量。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;5）把上一步获取的 BD entry右移 3 位（用于删除前 3 位包含的 metadata）来获取  BT 基址。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;6）把基址和偏移量相加从而得到 BT entry。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;7）Load BT entry。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：在 BT entry 中存储了指针的值，其用处是每次找到这个 BT entry 后需要把指针值和 BT entry中的指针值进行比较，如果不相等则默认这个指针的界限为 &lt;code class=&quot;highlighter-rouge&quot;&gt;INIT&lt;/code&gt; ，主要用于兼容性考虑。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;三参考&quot;&gt;（三）、参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://intel-mpx.github.io/design/&quot;&gt;https://intel-mpx.github.io/design/&lt;/a&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文主要简单介绍 MPX</summary></entry><entry><title type="html">SSA Form and PHI Nodes</title><link href="blog.dianzhangchen.com/llvm/tech/2019/02/14/ssa-form-and-phi-nodes.html" rel="alternate" type="text/html" title="SSA Form and PHI Nodes" /><published>2019-02-14T20:26:29+08:00</published><updated>2019-02-14T20:26:29+08:00</updated><id>blog.dianzhangchen.com/llvm/tech/2019/02/14/ssa-form-and-phi-nodes</id><content type="html" xml:base="blog.dianzhangchen.com/llvm/tech/2019/02/14/ssa-form-and-phi-nodes.html">&lt;p&gt;本文主要简单介绍 LLVM 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHINode&lt;/code&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;最近接触到追踪一个变量在程序中的使用。当对 LLVM IR 中 instruction 进行分析的时候，遇到类似如下的代码：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;%19&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%entry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%land.rhs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该指令为 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHINode&lt;/code&gt;，为 llvm 中的一个指令类，继承于 &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm::Instruction&lt;/code&gt;，具体继承关系和 llvm 源码见：&lt;a href=&quot;https://llvm.org/doxygen/classllvm_1_1PHINode.html&quot;&gt;PHINode 类&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;一ssa-简介&quot;&gt;（一）、SSA 简介&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
在正式介绍 PHI Nodes 之前首先需要了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSA&lt;/code&gt; ，因为所有的 LLVM IR 指令都是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSA&lt;/code&gt; 形式表示。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;1ssa&quot;&gt;（1）、SSA&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SSA (static single assignment form)&lt;/code&gt; ：&lt;strong&gt;静态一次性赋值&lt;/strong&gt;；意思是说&lt;strong&gt;每个变量（虚拟寄存器）都只能被赋值一次&lt;/strong&gt;；这样做的好处是可以方便优化代码。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nl&quot;&gt;y :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;y :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;x :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;显然，在以上代码中我们能够一眼看出第一行代码是多余的，因为在第三行使用的 $y$ 的值是来自第二行对 $y$ 的赋值，而不是来自第一行对 $y$ 的赋值。而对于程序来说并不能直观的得出第一行是多余的，需要做数据流分析才能判断第一行是多余的。$SSA$ 恰好能够解决该问题，以上代码用 $SSA$ 形式来表示的话：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nl&quot;&gt;y1 :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;y2 :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;x1 :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;很明显，用以上表示方法程序不需要做数据流分析就能够知道第三行使用的 $y$ 是来自第二行的定义。当然，使用 $SSA$ 还能做很多别的优化，我也没有细看，这里就不再赘述了，有兴趣的话可以参考：&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single_assignment_form&quot;&gt;维基百科上的介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;2生成-ssa-形式的指令&quot;&gt;（2）、生成 SSA 形式的指令&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;
我们可以通过探究 $SSA$ 指令的生成知道为什么要引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI Nodes&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;把一个普通程序转化为 $SSA$ 形式，最简单的做法就是把每一次的赋值都赋值给一个新的变量（或者说是同一个变量的不同版本），同时在使用变量的时候，使用能够到达该程序点对应的”版本”。
举个例子，在下图的控制流图中，左边图一是原程序流图，右图为按照上述方法生成的 SSA 形式的程序流图。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;图一：原程序流图&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;图二：SSA 形式流图（中间版本）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/7/73/SSA_example1.1.png&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/f/f7/SSA_example1.2.png&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们可以发现在右图最底下的基本块中，对于 $y$ 的使用可能来自 $y_1$ 也可能来自 $y_2$，取决于程序是从哪条路径到达该程序点的。为了解决该问题，引入了一条新的语句：$\phi$，该语句会生成一个新的 $y$ 的定义 $y_3$，$y_3$ 的值会根据控制流是从哪条路径到达而选择不同的值 $y_1$ 或 $y_2$:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;图三：SSA 形式流图&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/84/SSA_example1.3.png&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上述的 $\phi$ 函数就是我们所要介绍的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI Node&lt;/code&gt;。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
$ y_3 \leftarrow \phi (y_1, y_2) $
&lt;/p&gt;
&lt;p&gt;PHI node 根据控制流是从哪一个 block ( $y_1\leftarrow x_2 * 2$ 或 $y_2\leftarrow x_2 -3$) 到达，来决定使用 $y_1$ 或 $y_2$ 赋值给 $y_3$。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;二phi-nodes-简介&quot;&gt;（二）、PHI Nodes 简介&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
在上一节中我们已经介绍了为什么要引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI Nodes&lt;/code&gt;；本节主要通过一个例子来讲解 PHI Nodes。&lt;/p&gt;

&lt;p&gt;回顾一下 PHI Nodes：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;PHI Nodes 会记录是从哪个 control-flow 过来的，从而使用相应的值（类似多路复用器）。&lt;/li&gt;
    &lt;li&gt;并没有实际实现，只是编译器会保证相应的 virtual registers 映射到了同一个 physical register。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，以下左图为原程序，右图为相应的 control-flow。
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/LLVM/PHINode/phinode_no_ssa.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
当引入 SSA 形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/LLVM/PHINode/phinode_ssa.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
对于一个 PHI node 可以表示为：&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%result = phi i32 [value1, BB label1], [value2, BB label2]&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;当从 label1 所对应的 basic block(BB) 路径到达 PHI node, 则 result 的值为 value1; 同理,当从 label2 所对应的 basic block路径到达 PHI node, 则 result 的值为 value2。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;三参考链接&quot;&gt;（三）、参考链接&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;http://www.llvmpy.org/llvmpy-doc/dev/doc/llvm_concepts.html#ssa-form-and-phi-nodes&quot;&gt;http://www.llvmpy.org/llvmpy-doc/dev/doc/llvm_concepts.html#ssa-form-and-phi-nodes&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single_assignment_form&quot;&gt;https://en.wikipedia.org/wiki/Static_single_assignment_form&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://cs.uni-paderborn.de/fileadmin/informatik/fg/hit/teaching/SS2017/HWSW-Codesign/02-Compiler-LLVM.pdf&quot;&gt;https://cs.uni-paderborn.de/fileadmin/informatik/fg/hit/teaching/SS2017/HWSW-Codesign/02-Compiler-LLVM.pdf&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://llvm.org/doxygen/classllvm_1_1PHINode.html&quot;&gt;https://llvm.org/doxygen/classllvm_1_1PHINode.html&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文主要简单介绍 LLVM 中的 PHINode。</summary></entry><entry><title type="html">Test for blogging</title><link href="blog.dianzhangchen.com/jekyll/tech/2019/02/07/test-for-blogging.html" rel="alternate" type="text/html" title="Test for blogging" /><published>2019-02-07T12:55:13+08:00</published><updated>2019-02-07T12:55:13+08:00</updated><id>blog.dianzhangchen.com/jekyll/tech/2019/02/07/test-for-blogging</id><content type="html" xml:base="blog.dianzhangchen.com/jekyll/tech/2019/02/07/test-for-blogging.html">&lt;p&gt;该文用于说明写 blog 的一些格式要求。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建-blog&quot;&gt;新建 blog&lt;/h3&gt;

&lt;p&gt;当需要创建一个新的 blog 时(假设名字为：Test for blogging), 在 blog 的主目录中输入以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopress new post Test for blogging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该命令会在文件夹 &lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt; 中生成文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;2019-02-07-test-for-blogging.markdown&lt;/code&gt;, 文件名前面的时间是自动添加的，编辑该文件为以下格式：&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;layout: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;title: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Test for blogging&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;date: &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2019&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;07&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;08&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;categories: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Jekyll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Tech&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;author: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cdz&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;excerpt_separator: &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;这里编写&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blog&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;正文。中间可以用&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;分割。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;: 表示该 blog 属于哪个 layout，不同的 layout 会有不同的显示，具体显示的格式规定在文件夹 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt; 中，当为 &lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt; 时表示按照 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts/post.html&lt;/code&gt; 的格式显示。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;: 表示该 blog 的生成时间，是自动生成的。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;categories&lt;/code&gt;: 表示该 blog 属于那一类，可以自己定义，当属于多个类的时候需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;[category1, category2 ]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;author&lt;/code&gt;: 表示该 blog 的博主。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;excerpt_separator: &amp;lt;!--more--&amp;gt;&lt;/code&gt;: 表示在该 blog 中使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 分割， &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 的前一半内容会显示在home中的预览中，后一半只有点进博客才能看到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里是插入网址的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 格式为：[文中显示内容][网页地址记号]
// 在文本的最后：[网页地址记号]：网页地址
[CDZ's Blog][cdz-blog]

[cdz-blog]: https://blog.dianzhangchen.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;预览-blog&quot;&gt;预览 blog&lt;/h3&gt;

&lt;p&gt;在主目录中输入：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build
jekyll serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时候在浏览器中输入：&lt;a href=&quot;http://localhost:4000/&quot;&gt;http://localhost:4000/&lt;/a&gt; 就可以去看效果。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;部署-blog-到网站&quot;&gt;部署 blog 到网站&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopress deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写-markdown-的一些技巧&quot;&gt;编写 markdown 的一些技巧&lt;/h3&gt;

&lt;h4 id=&quot;1插入空行&quot;&gt;(1)、插入空行&lt;/h4&gt;

&lt;p&gt;插入空行使用 html 的语法，只需要在相应的位置插入 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br/&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;2插入图片&quot;&gt;(2)、插入图片&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![image-title-here](/path/to/image.jpg){:class=&quot;img-responsive&quot;}

// 或者按照以下方法，使用 html 语法, 可以调节图片的大小
&amp;lt;p&amp;gt;&amp;lt;img src=&quot;/image/DongBei/barbecue.jpg&quot; width=&quot;500&quot;&amp;gt;&amp;lt;/p&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一种方法效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/test/icon.ico&quot; alt=&quot;test_image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二种方法效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/test/icon.ico&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">该文用于说明写 blog 的一些格式要求。</summary></entry><entry><title type="html">在东北</title><link href="blog.dianzhangchen.com/life/travel/2019/02/07/md.html" rel="alternate" type="text/html" title="在东北" /><published>2019-02-07T10:26:57+08:00</published><updated>2019-02-07T10:26:57+08:00</updated><id>blog.dianzhangchen.com/life/travel/2019/02/07/md</id><content type="html" xml:base="blog.dianzhangchen.com/life/travel/2019/02/07/md.html">&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/image/DongBei/snow_train.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;扬帆&quot;&gt;扬帆&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;今年上海的雪下得吊人胃口，虽说来的早，可落地即化，未免有点失望。&lt;br /&gt;
对于南方人，能在冬天看看雪，吃点冰块就很幸福了。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;要不要一起去东北玩？ &lt;br /&gt;
妥！！！&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;出发前对于东北充满好奇。&lt;br /&gt;
零下20度是什么概念？&lt;br /&gt;
一出山海关，都是赵本山？&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;接着就是各种准备。加厚棉袜，手套，雪地靴，雷锋帽，暖宝宝。&lt;br /&gt;
出于对零下20度的敬畏，线上线下一顿忙活。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;奉天&quot;&gt;奉天&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
到沈阳，住进宾馆，已是傍晚。&lt;br /&gt;
随后就在中街溜达，刚开始去了个假的中街。&lt;br /&gt;
一行人就感叹，怎么着也是个省会城市的最有名的步行街，怎么能这么小？&lt;br /&gt;
失望的找地铁站回家途中，走到了真正的中街，豁然开朗。&lt;br /&gt;
它拥有了一个步行街该有的繁华，绚丽。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不得不说，东北的暖气是神一般的存在。&lt;br /&gt;
当晚在宾馆，热得飞起。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;第二天就去了沈阳冰雪大世界，各种游乐项目：冰上碰碰车，雪摩托，雪地飞狐。&lt;br /&gt;
最刺激的还是冰滑道：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/shenyang_ski.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;泡澡&quot;&gt;泡澡&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;刚开始提出去泡澡计划，我想都没想就拒绝了。&lt;br /&gt;
之后被各种安利，想想东北特色的洗澡文化，来都来了，不体验一把还是有点遗憾的。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;这边泡澡基本流程就是：冲、泡、搓、蒸、冲。&lt;br /&gt;
搓澡的时候会有各种选择，有红酒搓，醋搓；红酒搓听起来就x格高，自然就选了这个。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在一个类似火车卧铺的床位上加上一层一次性桌布，往上一躺。&lt;br /&gt;
搓澡师当面开封一个新的搓澡巾, 然后就卡卡搓上了。&lt;br /&gt;
变搓边唠嗑，东北话自带幽默属性。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;想体验东北文化，就得整全套的。&lt;br /&gt;
搓澡之后的烧烤是必须的，东北澡堂周边必有烧烤店。&lt;br /&gt;
几盘烧烤，一瓶啤酒，甚是满足。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/DongBei/barbecue.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;哈尔滨&quot;&gt;哈尔滨&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;哈尔滨就更冷了，拿手机拍照都需要很大的勇气。&lt;br /&gt;
一是，拍照需要摘下手套，又冷又麻烦。&lt;br /&gt;
再者，手机用电很快，且容易冻关机。&lt;br /&gt;
在风大的地方，很多人是倒退走路的：&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/walk_backward.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
在这可以看到浓郁俄罗斯风情的中央大街，随处可听到 “喀秋莎”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/central_street.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
在中央大街附近还有索菲亚大教堂，是一个拜占庭风格的教堂，据说是沙俄第四步兵师修建中东铁路时修建的一座随军教堂。&lt;br /&gt;
夜晚的教堂气宇轩昂。&lt;br /&gt;
同行的一小伙，硬是拿着 GoPro 绕着教堂跑了一圈。&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/church.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;滑雪&quot;&gt;滑雪&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;早上5点多起来坐车去，亚布力滑雪场。&lt;br /&gt;
在中途休息站能看到很有东北特色的小贩。&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/shop.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;滑雪之前还是被忽悠加了一些别的项目，马拉犁、冰滑道、等一些热门娱乐。&lt;br /&gt;
马拉着一车人，在雪地里“飞驰”。&lt;br /&gt;
同车的一大叔开玩笑道：“这马不给力啊，别弄的我们都得下去推车了”。&amp;gt;_&amp;lt;||| &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/malali2.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;也终于到了滑雪的时候。&lt;br /&gt;
曾听说滑雪是白色鸦片，第一次接触滑雪的人，要么从此别过，要么就沾上这个“鸦片”。&lt;br /&gt;
我们滑雪前都定了一个小目标：能够独立缓慢滑行。&lt;br /&gt;
由于我们都有穷病就没有请教练 &amp;gt;_&amp;lt;|||&lt;br /&gt;
刚开始的时候，五米一小摔倒，十米一大摔。&lt;br /&gt;
幸得滑雪场旁边一大爷给我指点，后面摔倒明显减少，就算摔也比之前摔的有尊严一点。&lt;br /&gt;
我感觉滑雪和开车也有相似之处，滑的时候不要盯着脚下，要看前方。&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/ski2.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;松花江&quot;&gt;松花江&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;松花江上结了一层厚冰，上面堆满了雪人，这得有多少人对雪爱的深沉&lt;br /&gt;
我们决定冰面上横跨松花江。&lt;br /&gt;
一行人，围巾遮面，低头避风就缓慢出发了。&lt;br /&gt;
走到松花江中间，环顾四周，突感大自然的神奇，一条活动的江水居然能够结冰，且如此结实。&lt;br /&gt;
由于不敢和寒风正面刚，本来应该垂直跨过松花江，硬生生走出了一条大斜线。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/DongBei/snow_man.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;吃&quot;&gt;吃&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在东北吃的最感人的就属冰糖葫芦了，五块钱一串，冰冰的、酸酸的、甜甜的，甚是可口。&lt;br /&gt;
这让我想起霸王别姬中的桥段，一小孩在自杀之前最后的愿望就是吃冰糖葫芦。&lt;br /&gt;
回上海之前，还特意早起去马迭尔买了几串冰糖葫芦带回来。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;其它的特色食物就是：红菜汤，锅包肉，老太太烧烤，烤冷面，秋林红肠；除了老太太烧烤有点失望外，其余都还算满意。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;后面，还特意去了趟哈尔滨工业大学，感受一波北方大学的建筑风格。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;“世界不是苟且，世界是远方，行万里路才能回到内心深处；未来不是岁数，未来是谜雾，读万卷书才能看清皓月繁星。” &lt;br /&gt;
好好学习，好好工作，赚够旅游的盘缠。&lt;br /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html"></summary></entry></feed>