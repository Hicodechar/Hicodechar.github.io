<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-29T13:46:56+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">CDZ</title><subtitle>Welcome to cdz's blog. Any questions or suggesions, please contact me.</subtitle><entry><title type="html">Postgres TOAST</title><link href="http://localhost:4000/tech/2019/07/29/postgres-toast.html" rel="alternate" type="text/html" title="Postgres TOAST" /><published>2019-07-29T11:52:38+08:00</published><updated>2019-07-29T11:52:38+08:00</updated><id>http://localhost:4000/tech/2019/07/29/postgres-toast</id><content type="html" xml:base="http://localhost:4000/tech/2019/07/29/postgres-toast.html">&lt;p&gt;本文主要介绍 Postgres 中的 Toast 技术&lt;/p&gt;

&lt;!--more--&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;一toast-技术&quot;&gt;（一）、Toast 技术&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-简介&quot;&gt;1.1 简介&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Toast&lt;/code&gt; 是一种&lt;strong&gt;超尺寸字段存储技术（ The Oversized Attribute Storage Technique）&lt;/strong&gt; 。是 Postgres 中存储超长字段的方法，通常在 Postgres 中：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个 Row（数据行）都存储在大小为 8kb 的 Page（页） 中&lt;/li&gt;
  &lt;li&gt;每行数据不会跨页存储&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了支持一行数据超过 8kb 的情况，所以引入了 $Toast$ 技术。&lt;/p&gt;

&lt;h3 id=&quot;12-技术细节&quot;&gt;1.2 技术细节&lt;/h3&gt;

&lt;p&gt;当 Postgres 需要存储一个超过 2kb 的行的时候，$Toast$ 技术就会派上用场；Postgres 首先会尝试使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;压缩技术&lt;/code&gt; ，当该行能够被压缩到 2kb 以下的话，那么问题也就解决了。如果压缩后，大小还超过 2kb 的话，Postgres 就会把这个被压缩的数据切分为大小为 2kb 的数据块（chunk），然后每个数据块都存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Toast Table&lt;/code&gt; 中。每个普通的 $Postgres  Table$ 都有一个与之对应的 $Toast Table$，把超长数据切分后存储在这个 $Toast Table$ 中，存储在 $Toast Table$ 中的数据也称为&lt;code class=&quot;highlighter-rouge&quot;&gt;TOASTed&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;每个 $Toast Table$ 有&lt;strong&gt;三列&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chunk_id&lt;/code&gt;：用于区分 Toast table 中的数据块(chunk) 属于哪个 $TOASTed$ 数据；也就是&lt;strong&gt;区分哪些数据块属于同一原始数据&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chunk_seq&lt;/code&gt;：用于区分数据块之间的&lt;strong&gt;顺序(orders)&lt;/strong&gt;；比如排第一的数据块 $chunk_seq=0$，排第二的数据块 $chunk_seq=1$ 等等。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chunk_data&lt;/code&gt;：用于真正存储&lt;strong&gt;数据&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当进行 $query$ 的时候，当需要读取 $TOASTed$ 数据时，Postgres 会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;(chunk_id, chunk_seq)&lt;/code&gt; 来当作索引，去 $Toast Table$ 读取数据编号为 $chunk_id$ 且按照 &lt;code class=&quot;highlighter-rouge&quot;&gt;chunk_seq&lt;/code&gt; 排序的数据块；把这相关的数据块都读走，然后进行解压缩，就能够给得到原始的数据了。&lt;/p&gt;

&lt;p&gt;特定情况下，$Toast$ 技术还能够提升性能；当不需要读取 $TOASTed$ 原始数据时，我们可以不把 Toast table 中的数据块读入到内存。&lt;/p&gt;

&lt;h3 id=&quot;13-实例&quot;&gt;1.3 实例&lt;/h3&gt;

&lt;p&gt;我们可以通过 Postgres 中普通的数据表，得到相应的 &lt;strong&gt;Toast table&lt;/strong&gt; 。
首先，我们创建一个 $messages$ 表，有一个单一的列 $message$:&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;messages&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，在表中插入一些随机的字符串：&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;messages&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;string_agg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generate_series&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generate_series&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样我们就得到了一个表，里面有 $TOASTed$ 数据；首先，我们需要从这个 $messages$ 表得到相应的 $Toast table$ 的名字，可以通过以下命令获得：&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reltoastrelid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regclass&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pg_class&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;relname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'messages'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;reltoastrelid&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-------------------------&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pg_toast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg_toast_59611&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这行语句从 &lt;code class=&quot;highlighter-rouge&quot;&gt;pg_class&lt;/code&gt; 表中读取相应的信息（ &lt;code class=&quot;highlighter-rouge&quot;&gt;pg_class&lt;/code&gt; 表是 Postgres 中用于存储&lt;code class=&quot;highlighter-rouge&quot;&gt;表的metadata&lt;/code&gt;的一个表）。&lt;/p&gt;

&lt;p&gt;当我们有了相应的 $Toast table$ 的名字后，我们可以输出相应的信息：&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pg_toast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg_toast_59611&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;chunk_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk_seq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk_data&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;----------+-----------+------------&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;59617&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;         &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x4c4457&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;59617&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;         &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x424d4b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意：chunk_data 的内容是&lt;strong&gt;压缩&lt;/strong&gt;的&lt;strong&gt;binary格式&lt;/strong&gt;的数据，所以不是 human readable.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;二postgres-源码阅读&quot;&gt;（二）、Postgres 源码阅读&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;并不是全部数据类型都支持toast，对于有些不会产生大字段数据的字段类型(比如date,time,boolean等)是完全没必要用到Toast技术。支持Toast的数据类型应当时变长的 &lt;code class=&quot;highlighter-rouge&quot;&gt;varlena&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varlena&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;vl_len_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;        &lt;span class=&quot;cm&quot;&gt;/* Do not touch this field directly! */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;vl_dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FLEXIBLE_ARRAY_MEMBER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Data content is here */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上数据类型并不是表示一个&lt;code class=&quot;highlighter-rouge&quot;&gt;toasted&lt;/code&gt; 数据类型的，因为它过于简单，没有包含是否压缩，以及是否使用 toast 技术的描述。该数据类型仅仅表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;de-toasted&lt;/code&gt; 数据。
对于表示 toasted 数据，应当使用：(定义在 &lt;code class=&quot;highlighter-rouge&quot;&gt;src/include/postgres.h&lt;/code&gt; 中：)&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;                        &lt;span class=&quot;cm&quot;&gt;/* Normal varlena (4-byte length) */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;uint32&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FLEXIBLE_ARRAY_MEMBER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;va_4byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;                        &lt;span class=&quot;cm&quot;&gt;/* Compressed-in-line format */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;uint32&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;uint32&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_rawsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Original data size (excludes header) */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FLEXIBLE_ARRAY_MEMBER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Compressed data */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;va_compressed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varattrib_4b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint8&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FLEXIBLE_ARRAY_MEMBER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Data begins here */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varattrib_1b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* TOAST pointers are a subset of varattrib_1b with an identifying tag byte */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint8&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;cm&quot;&gt;/* Always 0x80 or 0x01 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint8&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;cm&quot;&gt;/* Type of datum */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;va_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FLEXIBLE_ARRAY_MEMBER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Type-specific data */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varattrib_1b_e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么当我拿到一个变长数据类型（&lt;code class=&quot;highlighter-rouge&quot;&gt;varlena&lt;/code&gt;）的数据时，我怎么知道它是否使用到了 toast 技术呢？以及是否压缩了呢？这就用到了以下的宏：&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;src/include/postgres.h&lt;/code&gt; 中：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * Bit layouts for varlena headers on big-endian machines:
 *
 * 00xxxxxx 4-byte length word, aligned, uncompressed data (up to 1G)
 * 01xxxxxx 4-byte length word, aligned, *compressed* data (up to 1G)
 * 10000000 1-byte length word, unaligned, TOAST pointer
 * 1xxxxxxx 1-byte length word, unaligned, uncompressed data (up to 126b)
 *
 * Bit layouts for varlena headers on little-endian machines:
 *
 * xxxxxx00 4-byte length word, aligned, uncompressed data (up to 1G)
 * xxxxxx10 4-byte length word, aligned, *compressed* data (up to 1G)
 * 00000001 1-byte length word, unaligned, TOAST pointer
 * xxxxxxx1 1-byte length word, unaligned, uncompressed data (up to 126b)
 *
 * The &quot;xxx&quot; bits are the length field (which includes itself in all cases).
 * In the big-endian case we mask to extract the length, in the little-endian
 * case we shift.  Note that in both cases the flag bits are in the physically
 * first byte.  Also, it is not possible for a 1-byte length word to be zero;
 * this lets us disambiguate alignment padding bytes from the start of an
 * unaligned datum.  (We now *require* pad bytes to be filled with zero!)
 *
 * In TOAST pointers the va_tag field (see varattrib_1b_e) is used to discern
 * the specific type and length of the pointer datum.
 */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * Endian-dependent macros.  These are considered internal --- use the
 * external macros below instead of using these directly.
 *
 * Note: IS_1B is true for external toast records but VARSIZE_1B will return 0
 * for such records. Hence you should usually check for IS_EXTERNAL before
 * checking for IS_1B.
 */&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#define VARATT_IS_4B(PTR) \
((((varattrib_1b *) (PTR))-&amp;gt;va_header &amp;amp; 0x80) == 0x00)  # 判断 ptr 指针所指向的是不是：aligned；是则返回 1。
#define VARATT_IS_4B_U(PTR) \
((((varattrib_1b *) (PTR))-&amp;gt;va_header &amp;amp; 0xC0) == 0x00)  # 判断 ptr 指针所指向的是不是：aligned 且 非压缩 ；是则返回 1。
#define VARATT_IS_4B_C(PTR) \
((((varattrib_1b *) (PTR))-&amp;gt;va_header &amp;amp; 0xC0) == 0x40)  # 判断 ptr 指针所指向的是不是：aligned 且 压缩 ；是则返回 1。
#define VARATT_IS_1B(PTR) \
((((varattrib_1b *) (PTR))-&amp;gt;va_header &amp;amp; 0x80) == 0x80)  # 判断 ptr 指针所指向的是不是：非 aligned ；是则返回 1。
#define VARATT_IS_1B_E(PTR) \
((((varattrib_1b *) (PTR))-&amp;gt;va_header) == 0x80)         # 如果 ptr 指针所指向的结构体中，head 的最高两位为：10；是则是：TOAST pointers
#define VARATT_NOT_PAD_BYTE(PTR) \
(*((uint8 *) (PTR)) != 0)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;三参考资料&quot;&gt;（三）、参考资料&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;https://malisper.me/postgres-toast/  &lt;br /&gt;
https://my.oschina.net/Kenyon/blog/113026 &lt;br /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文主要介绍 Postgres 中的 Toast 技术</summary></entry><entry><title type="html">《教父》– 简评</title><link href="http://localhost:4000/life/2019/07/29/GodFather.html" rel="alternate" type="text/html" title="《教父》-- 简评" /><published>2019-07-29T01:44:39+08:00</published><updated>2019-07-29T01:44:39+08:00</updated><id>http://localhost:4000/life/2019/07/29/GodFather</id><content type="html" xml:base="http://localhost:4000/life/2019/07/29/GodFather.html">&lt;p&gt;&lt;strong&gt;The Godfather is the I-ching.&lt;/strong&gt; &lt;br /&gt;
&lt;strong&gt;The Godfather is the sum of all wisdom.&lt;/strong&gt; &lt;br /&gt;
&lt;strong&gt;The Godfather is the answer to any question.&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p align=&quot;right&quot;&gt; --《You’ve got mail》&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;一简评&quot;&gt;（一）、简评&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/image/movies/godfather/godfather.png&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;《教父》是第 45 届&lt;code class=&quot;highlighter-rouge&quot;&gt;奥斯卡最佳影片&lt;/code&gt;；非常有时代特色。影片从著名长篇小说改编而来，也拿到了&lt;code class=&quot;highlighter-rouge&quot;&gt;最佳改编奖&lt;/code&gt;。同时，马龙白兰度对教父的演绎，也可以说是入门三分，无其左右，有当黑帮大佬的凶狠、智慧与高冷，同时当面对儿子的死亡时又表现出充满复杂的悲伤，所以马龙白兰度也拿到了当时的&lt;code class=&quot;highlighter-rouge&quot;&gt;最佳男主角&lt;/code&gt;奖。该电影在 &lt;code class=&quot;highlighter-rouge&quot;&gt;IMDB 排名第二&lt;/code&gt;，是一个时代的象征和永恒的经典。&lt;/p&gt;

&lt;p&gt;这部电影被成为是&lt;code class=&quot;highlighter-rouge&quot;&gt;男人的圣经&lt;/code&gt;。这么评价也是有原因的，表面上这是一部讲述黑帮的斗争，其实电影一直强调家庭对于男人的意义：&lt;code class=&quot;highlighter-rouge&quot;&gt;The man who doesn't spend time with his family ... can never be a real man.&lt;/code&gt; ；老教父虽然在事业上是刀光剑影，却从不把自己的事业上的烦恼困惑转移到自己的家人身上，留给家人的都是欢笑和慈祥：&lt;code class=&quot;highlighter-rouge&quot;&gt;Papa never talked business at the table in front of the kids.&lt;/code&gt;。他用行动诠释了什么是责任，什么是智慧。&lt;/p&gt;

&lt;p&gt;国外很多影视剧都在强调 &lt;code class=&quot;highlighter-rouge&quot;&gt;Family&lt;/code&gt;，之前追的电视剧《初代吸血鬼》，也是讲述了吸血鬼始祖们如何捍卫自己的家族 ：&lt;code class=&quot;highlighter-rouge&quot;&gt;Family，always and forever&lt;/code&gt;。近期完结的 《权利的游戏》，也是讲述家族之间的斗争，以及史塔克家族兄妹间如何在亡族的命运下，互相搀扶，走向权利的制高点。&lt;/p&gt;

&lt;p&gt;当然，老教父给人映像深刻的不仅仅是家族观念，还有他的为人处世：守信、广结好友、有底线等等，这是一部值得用心慢慢品味的电影。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;二经典语录&quot;&gt;（二）、经典语录&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;以下是该电影的比较经典语录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I'm gonna make him an offer he can't refuse. 
我会给他一个他无法拒绝的提议
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;What have I ever done to make you treat me so disrespecfully?
If you'd come to me in friendship, then the scum that ruined your daughter would be suffering this ever day.

And if, by chance, an honest man like yourself should make enemies, then they would be my enemies.
And then they would fear you.

Be my friend?
God father...

我到底做了什么，让你这么不尊重我？
如果你以朋友身份来找我，那么伤害你女儿的混蛋就会收到折磨。
而且，你这种诚实人的敌人就是我的敌人。
那么，他们就会怕你。

当我的朋友？
教父...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;You spend time with your family ?
Good! Because the man who doesn't spend time with his family ... can never be a real man.

你花过时间与家人共聚吗
很好，因为不抽空陪家人的男人不是真正的男人。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Papa never talked business at the table in front of the kids.
爸爸从来不在餐桌上当着孩子们谈论公事。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Never tell anybody outside the family what you're thinking.
别让外人知道你在想什么。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I spent my life tryin' not to be careless.
Women and children can be careless, but not men.
我花了一辈子就学会了“小心”，
女人和小孩可以粗心大意，但是男人不行。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I worked my whole life--I don't apologize--to take care of my family,
and i refuse to be a fool...dancing on a string held by all those big shots.
我干了一辈子，没什么遗憾的，我照顾了我的家人。
但我绝不当傻瓜，让那些大人物在后面操纵我
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I don't apologize, That my life.
But i thought that when it was your time...you would the one to hold the strings.
我不必遗憾，那就是我的生活。
但是我想过， 有一天你能够当那些操纵的人。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>cdz</name></author><summary type="html">The Godfather is the I-ching. The Godfather is the sum of all wisdom. The Godfather is the answer to any question. --《You’ve got mail》</summary></entry><entry><title type="html">MapReduce</title><link href="http://localhost:4000/tech/distributed_system/2019/04/11/mapreduce.html" rel="alternate" type="text/html" title="MapReduce" /><published>2019-04-11T20:44:48+08:00</published><updated>2019-04-11T20:44:48+08:00</updated><id>http://localhost:4000/tech/distributed_system/2019/04/11/mapreduce</id><content type="html" xml:base="http://localhost:4000/tech/distributed_system/2019/04/11/mapreduce.html">&lt;p&gt;本文简单介绍分布式计算框架 MapReduce 
&lt;!--more--&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;一引入&quot;&gt;（一）、引入&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MapReduce&lt;/strong&gt; 的设计灵感来源于 Python 中的 $map$ 和 $reduce$ 函数。首先来看一下这两个函数是什么样的：&lt;/p&gt;

&lt;p&gt;$map$ : 接收一个函数 $f$ 和 一个数组 $list$ （或者可以 iterate 的一串数据） , 然后把该函数运用在该数组中的每个元素（element）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/1_map.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;$reduce$：接收一个函数 $g$ 和 一个数组 $list$ ；然后对该 list 中的前两个元素运行函数 $g$ ，生成的结果当成 list 的一个元素，然后递归取前两个元素再次运行函数 $g$ 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/2_reduce.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;实例&quot;&gt;实例：&lt;/h4&gt;

&lt;p&gt;问题：给定一个数组，求该数组中每个元素都平方，然后相加的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/3_map_reduce.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;所以以上的执行过程可以看成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/4_map_reduce.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mapper&lt;/strong&gt;：就是传给 $map$ 函数的处理函数；如以上例子的 $f$。
&lt;strong&gt;reducer&lt;/strong&gt;：就是传给 $reduce$ 函数的处理函数；如以上例子的 $g$。&lt;/p&gt;

&lt;p&gt;关键就在于程序员只需要去实现：$maper$ 和 $reducer$ 函数。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;二mapreduce&quot;&gt;（二）、MapReduce&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/5_relationship.png&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;可以把 MapReduce 看成是 $map+reduce$ &lt;code class=&quot;highlighter-rouge&quot;&gt;by key&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$mapper$ 函数并不是返回一个 value，而是返回一个 &lt;strong&gt;key-value&lt;/strong&gt; 对（可能很多有相同的 key ）&lt;/li&gt;
  &lt;li&gt;在调用 $reducer$ 函数之前，需要把所有 key 值相同的结果存到一起。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;21-过程&quot;&gt;2.1 过程&lt;/h4&gt;

&lt;p&gt;对于普通的 map＋reduce 的过程如图所示：&lt;/p&gt;

&lt;p&gt;给定 item ，通过 mapper 函数得到新的 value，然后再通过 reducer 函数得到最终结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/6_map_reduce.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;而对于 $MapReduce$ 的过程为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;给定输入 items ；通过 mapper 函数最终得到 &lt;strong&gt;key-value&lt;/strong&gt; pair&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;execution engine 会把所有相同的 key 归类到一起。也就是 &lt;strong&gt;Shuffle过程&lt;/strong&gt;（并不是程序员来完成）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后 reducer 会根据 key 来完成整合，最后得到 &lt;strong&gt;key-value&lt;/strong&gt; 对。（每一种 key 用一次 reducer 函数；当然，每个 reduce worker 可以处理多个 key）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/7_MapReduce.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;22-实例&quot;&gt;2.2 实例&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/8_example1.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/9_example2.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/10_example3.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;三mapreduce-系统架构&quot;&gt;（三）、MapReduce 系统架构&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/11_mapreduce_architecture.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，我们有个用户进程来协调程序如何运行。如它会根据数据规模来判断需要把任务拆分给多少个 mapper 和 reducer 去完成。
当它认为需要 5 个 mapper 去完成时，就会把数据拆成 5 份。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着产生很多 woker （map woker 和 reduce woker）；而且还会产生一个 &lt;strong&gt;master worker&lt;/strong&gt;，这个 $master$ 会作为用户的代理来协调整个过程，这样的话用户就可以去做别的事了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;$master$ 就会告诉 worker 去拿相应的数据（也就是分配数据的过程）。&lt;/li&gt;
  &lt;li&gt;map worker 就会本地完成 map 操作。&lt;/li&gt;
  &lt;li&gt;当 map 完成之后，$master$ 就会通知 reduce worker 去拿数据。&lt;/li&gt;
  &lt;li&gt;$reducer$ 完成 reduce 操作&lt;/li&gt;
  &lt;li&gt;最后把结果写到最终的文件中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以总结为：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;split&lt;/strong&gt; : 数据切分，分给不同的 map worker。（map worker 去拿数据）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;map&lt;/strong&gt; : map worker 本地调用 mapper 函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shuffle&lt;/strong&gt; : 把数据分配给不同的 reduce worker （相同的 key 的数据给同一个 reduce worker）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;reduce&lt;/strong&gt; ：reducer 完成 reduce 操作&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;finalize&lt;/strong&gt; ：数据整合&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;四mapreduce-完整过程&quot;&gt;（四）、MapReduce 完整过程&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step1-split-input-files-into-chunks-shards&quot;&gt;Step1 ：split input files into chunks (shards)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;切分数据成成很多 shard&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/12_split.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意&lt;/code&gt;： $\color{blue}{shards 的数量 M» worker 的数量}$&lt;/p&gt;

&lt;p&gt;原因：对于每个 worker 输入大小一样时并不能保证执行 shard 的时间一样（各个机器的执行速度并不一样）；所以说每个 worker 分配一个 shard 并不合理。而当 $M» worker 的数量$ 时，我们可以动态分配，哪些 worker 完成任务了就来取数据执行，这样做更加 balance 。&lt;/p&gt;

&lt;h3 id=&quot;step-2-fork-processes&quot;&gt;Step 2 ：fork processes&lt;/h3&gt;

&lt;p&gt;生成很多 wokers 和 master&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/13_fork.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step-3-map-task&quot;&gt;Step 3 ：map task&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从输入中读取 shard&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据输入数据生成 &lt;strong&gt;key-value&lt;/strong&gt; pair；最终结果存在 memory 中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/14_map.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step-4-create-intermediate-files&quot;&gt;Step 4 ：create intermediate files&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;把生成的 intermediate files 定期的写入到 disk 中&lt;/li&gt;
  &lt;li&gt;当完成后需要通知 master&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/15_intermediate.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step-4a-partitioning&quot;&gt;Step 4a ：partitioning&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;根据 key 进行排序&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Partition&lt;/strong&gt; function : 根据 key 值来决定分配给哪个 reduce worker&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;默认函数为：$\text{hash(key) mod M}$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;每个&lt;/strong&gt; reduce worker 会从 &lt;strong&gt;所有&lt;/strong&gt; map worker 中读取属于它的 partition。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;step-5-sorting-intermediate-data&quot;&gt;Step 5 ：sorting intermediate data&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;可以通过 master 知道数据位置&lt;/li&gt;
  &lt;li&gt;通过 RPC 从 map workers 的 &lt;strong&gt;local disk&lt;/strong&gt; 读取数据&lt;/li&gt;
  &lt;li&gt;根据 key 值排序&lt;/li&gt;
  &lt;li&gt;所有相同的 key 会 group 到一起&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/16_reduce.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;$\color{red}{相同的key一定去同一个reducer}$&lt;/p&gt;

&lt;h3 id=&quot;step-6-reduce-task&quot;&gt;Step 6 ：reduce task&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;根据 key 和与之对应的一系列 values 整合结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/17_combiner.png&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最终结果 append 到输出文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Distributed System/MapReduce/18_output.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step-7-return-to-user&quot;&gt;Step 7 ：return to user&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;五mapreduce-设计细节&quot;&gt;（五）、MapReduce 设计细节&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;31-locality&quot;&gt;3.1 Locality&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;输入文件（input）和输出文件（output）保存在 GFS 中。&lt;/li&gt;
  &lt;li&gt;MapReduce 运行在 GFS 的 chunkservers 上面；
    &lt;ul&gt;
      &lt;li&gt;主要是为了让计算和存储在相同的机器上&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Master 调度的时候尽量让含有相应数据的 worker 处理对应的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32-fault-tolerance&quot;&gt;3.2 Fault Tolerance&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Master 周期性的去 $ping$ 每个 worker （检查 worker fail）
    &lt;ul&gt;
      &lt;li&gt;如果一定时间内 worker 没有回复，则标记该 worker failed&lt;/li&gt;
      &lt;li&gt;把分配给该 worker 的任务重新分配给别的 worker （&lt;strong&gt;re-execution&lt;/strong&gt;）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Master failure （Master fail 的情况）
    &lt;ul&gt;
      &lt;li&gt;状态 checkpointed to GFS&lt;/li&gt;
      &lt;li&gt;由 GFS 来恢复 Master 并继续执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;33-straggler&quot;&gt;3.3 Straggler&lt;/h3&gt;

&lt;p&gt;问题：有的 worker 执行速度快，有的 worker 执行速度慢（straggler）；而这些速度慢的 worker 会使得整个计算时间变慢。&lt;/p&gt;

&lt;p&gt;解决方案：把任务分配给别的 worker，谁先做完就使用谁的结果。&lt;/p&gt;

&lt;h3 id=&quot;34-intermediate-key-value-pairs&quot;&gt;3.4 Intermediate key-value pairs&lt;/h3&gt;

&lt;p&gt;问题：中间结果表示 intermediate key-value 存储在哪里？存在 &lt;strong&gt;mapper&lt;/strong&gt; 的本地磁盘还是 &lt;strong&gt;reducer&lt;/strong&gt; 的本地磁盘。&lt;/p&gt;

&lt;p&gt;第一种方案：
&lt;strong&gt;Mapper-side&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;发送数据前做 partition；可以减少网络传输&lt;/li&gt;
  &lt;li&gt;如果 Map task failure ; 会造成部分数据丢失&lt;/li&gt;
  &lt;li&gt;如果 Reduce task failure; 只需要重新发送数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二种方案：
&lt;strong&gt;Reducer-side&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Pipeline -&amp;gt; overlap the transfer time&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说发送数据和执行可以 overlap （有的做完一部分 Map 后就可以发送数据，并不需要等待所有 Map worker 都做完后发送）&lt;/p&gt;

&lt;p&gt;目前普遍用的是第一种方案。&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文简单介绍分布式计算框架 MapReduce</summary></entry><entry><title type="html">Graph Processing</title><link href="http://localhost:4000/tech/graph/distributed_system/2019/04/11/graph-processing.html" rel="alternate" type="text/html" title="Graph Processing" /><published>2019-04-11T16:42:14+08:00</published><updated>2019-04-11T16:42:14+08:00</updated><id>http://localhost:4000/tech/graph/distributed_system/2019/04/11/graph-processing</id><content type="html" xml:base="http://localhost:4000/tech/graph/distributed_system/2019/04/11/graph-processing.html">&lt;p&gt;本文主要简单介绍一些主流的图处理算法&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;一基础知识&quot;&gt;（一）、基础知识&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1图的切分方式&quot;&gt;1、图的切分方式&lt;/h3&gt;
&lt;p&gt;图的切分方式可以分为两种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Edge-cut 边分割&lt;/li&gt;
  &lt;li&gt;Vertex-cut 顶点分割&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/1_edge_cut_vertex_cut.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;11edge-cut&quot;&gt;1.1、Edge-cut&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/2_1edge_cut.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;边分割的话，会把各个点分到不同的机器上，当遇到两个机器上的点有边时，则把边切开，并在两个机器上生成&lt;code class=&quot;highlighter-rouge&quot;&gt;ghost&lt;/code&gt;虚拟顶点；如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/2_2edge_cut.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;该方法的缺点是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;被分割的边，在各个机器上都有一份边，造成边的数量剧增。当边的数量本来就多的话，造成的overhead更大。&lt;/li&gt;
  &lt;li&gt;当 master 节点发生更改时，需要同步给其 ghost 节点，造成网络开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前两种流行的图处理框架：&lt;code class=&quot;highlighter-rouge&quot;&gt;GraphLab&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Pregel&lt;/code&gt; 用的都是&lt;code class=&quot;highlighter-rouge&quot;&gt;Edge-cut&lt;/code&gt;。保证节点均匀的分布在整个集群中间，边被切分成双份分散在整个集群中间。&lt;/p&gt;

&lt;h4 id=&quot;12vertex-cut&quot;&gt;1.2、Vertex-cut&lt;/h4&gt;

&lt;p&gt;引入 Vertex-cut 的目的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;减少通信开销&lt;/li&gt;
  &lt;li&gt;权衡图计算和图存储开销&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于边的数量很多的节点，如果使用 Edge-cut 的话，会使得相应的被切割的边数量变多；且该点对应的 ghost 顶点也很多，所以当需要通信的话，造成的通信开销也变大。&lt;/p&gt;

&lt;p&gt;所以提出了&lt;code class=&quot;highlighter-rouge&quot;&gt;Vertex-cut&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/3_vertex_cut.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;把 High-degree 的顶点进行&lt;code class=&quot;highlighter-rouge&quot;&gt;顶点分割&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这样做的好处是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;图中的&lt;code class=&quot;highlighter-rouge&quot;&gt;边的总数量不变&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;边被均匀的分布到不同的机器上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前两种流行的图处理框架：&lt;code class=&quot;highlighter-rouge&quot;&gt;PowerGraph&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;GraphX&lt;/code&gt; 用的都是&lt;code class=&quot;highlighter-rouge&quot;&gt;Vertex-cut&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2同步计算和异步计算&quot;&gt;2、同步计算和异步计算&lt;/h3&gt;

&lt;h4 id=&quot;21-同步计算&quot;&gt;2.1 同步计算&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/4_synchronous.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;当所有顶点都计算完之后，才能开始下一轮迭代计算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Stragglers(木桶的短板效应)&lt;/code&gt;；当某个顶点计算很慢时，所有别的顶点需要去等待它。
目前： &lt;code class=&quot;highlighter-rouge&quot;&gt;Pregel&lt;/code&gt; 用的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;同步计算&lt;/code&gt;的方式。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;22-异步计算&quot;&gt;2.2 异步计算&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/5_asynchronous.png&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;异步计算允许一些不造成冲突的顶点同时去更新。不是等所有顶点都完成了一次迭代之后才开始下一轮迭代；而是，只要不冲突的顶点就可以继续执行下去。
&lt;strong&gt;缺点：&lt;/strong&gt;为了避免冲突，需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;锁&lt;/code&gt;；而大量的锁会引起性能下降。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;一pregel&quot;&gt;（一）、Pregel&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;该算法是 Google 2010 年提出的图计算的算法。&lt;/p&gt;

&lt;p&gt;对图进行&lt;code class=&quot;highlighter-rouge&quot;&gt;edge-cut&lt;/code&gt;；是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;同步&lt;/code&gt;计算的方法。&lt;/p&gt;

&lt;p&gt;该算法以&lt;code class=&quot;highlighter-rouge&quot;&gt;Bulk Synchronous Parallel(BSP) 整体同步并行计算模型&lt;/code&gt; 为计算模型；
在分布式下面，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;message-passing(消息传递)&lt;/code&gt;在各个顶点之间传递消息；并且是&lt;code class=&quot;highlighter-rouge&quot;&gt;shared-nothing&lt;/code&gt;，也就是说对某个顶点的计算，其所需要的资源都在该顶点所在的机器上面。&lt;/p&gt;

&lt;p&gt;编程思想是：&lt;code class=&quot;highlighter-rouge&quot;&gt;Think like a vertex&lt;/code&gt;：每一个顶点去跑一个算法，然后并行的去在不同的顶点上运行算法。&lt;/p&gt;

&lt;p&gt;计算步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;收取邻接顶点发来的 messages&lt;/li&gt;
  &lt;li&gt;执行该点上的算法&lt;/li&gt;
  &lt;li&gt;更新该点的值&lt;/li&gt;
  &lt;li&gt;发出 message 给邻接点，激活邻接点重新计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/5_pregel.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;strong&gt;把计算和通信分离&lt;/strong&gt;；当所有顶点计算完之后，再统一进行消息传递；消息传递完之后，再统一下一次迭代的重新计算。直到收敛或者迭代到一定数量，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;同步计算&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;二graphlab&quot;&gt;（二）、GraphLab&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;strong&gt;认为 Pregel 这种同步计算的方式太慢&lt;/strong&gt;，特别是对于稀疏图的计算，每次迭代中计算的点的数量很少，且存在&lt;code class=&quot;highlighter-rouge&quot;&gt;木桶短板效应&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以&lt;strong&gt;主要思想&lt;/strong&gt;是：提出&lt;code class=&quot;highlighter-rouge&quot;&gt;异步计算&lt;/code&gt;的方法。&lt;/p&gt;

&lt;p&gt;首先，也需要把图进行划分，划分到不同的机器上；使用的划分方式是：&lt;code class=&quot;highlighter-rouge&quot;&gt;Edge-cut&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当要更新某个顶点时，&lt;code class=&quot;highlighter-rouge&quot;&gt;主动(pull)&lt;/code&gt;的向邻接顶点获取信息。注意这里和 Pregel 的区别，Pregel 使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;被动(push)&lt;/code&gt;的从邻接顶点收取消息。&lt;/p&gt;

&lt;p&gt;那么主动和被动有什么本质的区别吗？&lt;/p&gt;

&lt;p&gt;有，当主动 pull 的话，此时的邻接顶点可以是在  Inactive(空闲) 状态，也就是可以睡觉；而 push 模式的话，邻接顶点必须是 active 状态给你发送消息。&lt;/p&gt;

&lt;p&gt;计算步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从邻接顶点获取信息&lt;/li&gt;
  &lt;li&gt;更细顶点数据&lt;/li&gt;
  &lt;li&gt;如果需要，去叫醒邻接顶点开始计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这个算法中，并不是所有顶点同时收敛；而是动态的有些顶点先收敛，之后其他顶点开始慢慢收敛。&lt;/p&gt;

&lt;p&gt;那么，如何异步调度哪些顶点开始计算呢？&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Round Robin&lt;/li&gt;
  &lt;li&gt;FIFO&lt;/li&gt;
  &lt;li&gt;Priority&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;异步计算的缺点&lt;/code&gt;：当相邻两个顶点同时计算的话，会发生冲突，你拿邻接点开始计算，邻接点也拿你的数据开始计算，所以会造成 consistency 问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/6_graphlab.png&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;简而言之：&lt;strong&gt;用锁&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;三powergraph&quot;&gt;（三）、PowerGraph&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要想法&lt;/strong&gt;：对于 Pregel 和 GraphLab 都是基于Local(本地计算)，也就是当计算某个顶点的时候，其所需要的所有信息都在该本地机器上。但是，由于为了达到本地计算，会在每条分割边上产生一个 ghost 顶点；且&lt;strong&gt;这些 ghost 顶点之间需要同步&lt;/strong&gt;。当某个顶点的边的数量很多时，产生的ghost也变多（每分割一条边就会产生一个ghost）；所以当这个顶点更新时，需要通知所有的ghost，该操作会带来很大性能开销。&lt;/p&gt;

&lt;p&gt;造成以上问题的主要原因：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;edge-cut&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PowerGraph 思路&lt;/code&gt;：采用 &lt;code class=&quot;highlighter-rouge&quot;&gt;vertex-cut&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/6_powergraph.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;然后，计算的时候：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个机器&lt;code class=&quot;highlighter-rouge&quot;&gt;并行&lt;/code&gt;地计算自己的本地sum&lt;/li&gt;
  &lt;li&gt;最后整合到 master 主机上&lt;/li&gt;
  &lt;li&gt;master 主机更新数值之后，同步给告诉 mirror 节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/6_3powergraph.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
由于 PowerGraph 只要同步一个点的节点信息，所以可以&lt;code class=&quot;highlighter-rouge&quot;&gt;减少通信信息&lt;/code&gt;。同时对于边的数量非常大的顶点，可以把对于&lt;code class=&quot;highlighter-rouge&quot;&gt;该顶点&lt;/code&gt;的计算&lt;code class=&quot;highlighter-rouge&quot;&gt;并行&lt;/code&gt;到很多机器上运行。从而可以提高并行度。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;四powerlyra&quot;&gt;（四）、PowerLyra&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要想法&lt;/strong&gt;：由于之前的工作都是使用：&lt;strong&gt;one size fits all&lt;/strong&gt; 的想法；要不都是使用 vertex-cut 要不都使用 edge-cut。
这样做会带来问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当边的数量很多，但是使用 edge-cut 的话：
    &lt;ul&gt;
      &lt;li&gt;很大的竞争&lt;/li&gt;
      &lt;li&gt;很大的通信开销&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/7_1powerlyra.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当边的数量很少，但是使用 vertex-cut 的话：
    &lt;ul&gt;
      &lt;li&gt;没必要的同步操作；因为把一个顶点的计算，分布到多个机器上计算，然后整合。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/7_2powerlyra.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;主要思路&lt;/code&gt;：对于不同的顶点，动态采用不同的图分割方式和计算方式。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于边数很多的顶点，采用类似 vertex-cut 的切分方式&lt;/li&gt;
  &lt;li&gt;对于边数很少的顶点，采用类似 edge-cut 的切分方式&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;五graphchi&quot;&gt;（五）、GraphChi&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;单机下的图计算。&lt;/p&gt;

&lt;p&gt;对于一个很大的图一般是在内存中存不下的；所以一般都是存储在 disk 上，但是存储在 disk 上的话，会带来一些问题。比如读取数据的时候是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Random Access 的，所以读取数据很慢&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;想法：&lt;/code&gt; 如何更改图的数据结构，使得读取数据的时候能够达到好的性能，也就是&lt;strong&gt;相关的数据尽量在一起&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;做法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;把图分割成很多 sharded，使得每个 shared 能够一次性被加载到内存中&lt;/li&gt;
  &lt;li&gt;边的终节点相同的顶点分配到同一个 shared 中&lt;/li&gt;
  &lt;li&gt;对于每个shared中，按照初边序号进行排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/image/Graph Processing/8_graphchi.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;按照以上划分的话：当我需要读取与顶点1和顶点2有关的数据的话，只要把 shard 1 中的顶点全部读取，然后看其余的shard，找到src为1或2的信息；由于每个shard中按照 src 排序了，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;每个 shard 中需要读取的数据都在一起&lt;/code&gt;，减少 Random Access 的开销。&lt;/p&gt;

&lt;p&gt;对读取与顶点1和顶点2有关的数据的话，只要读取以上黄色的区域就可以了。&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文主要简单介绍一些主流的图处理算法</summary></entry><entry><title type="html">MPX</title><link href="http://localhost:4000/tech/2019/02/17/mpx.html" rel="alternate" type="text/html" title="MPX" /><published>2019-02-17T01:33:43+08:00</published><updated>2019-02-17T01:33:43+08:00</updated><id>http://localhost:4000/tech/2019/02/17/mpx</id><content type="html" xml:base="http://localhost:4000/tech/2019/02/17/mpx.html">&lt;p&gt;本文主要简单介绍 MPX&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;一mpx-简介&quot;&gt;（一）、MPX 简介&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Intel Memory Protection Extensions&lt;/code&gt; (Intel &lt;code class=&quot;highlighter-rouge&quot;&gt;MPX&lt;/code&gt;)  首次是在 2013 年提出，并在2015年引入到 Intel 的第六代处理器 Skylake. MPX 的目的是为 C/C++ 加入 bounds check 机制，从而保证内存安全。首先，看一下以下代码片段：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
   &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;// Array of pointers to objs&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// Pointer arithmetic on a&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// Pointer to obj at a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// Pointer to obj.len&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Total length of all objs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上程序分配了一个数组 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[10]&lt;/code&gt; 的指针, 也就是10个指针，每个指针都指向类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; 的对象，然后遍历前 M 个对象，把其中的 len 值相加得到总的len值（3-8行）total 。以上代码对应的 C 语言形式为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：&lt;code class=&quot;highlighter-rouge&quot;&gt;ai&lt;/code&gt; 是表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;指针&lt;/code&gt;，同时需要注意 &lt;code class=&quot;highlighter-rouge&quot;&gt;lenptr&lt;/code&gt; 如何指向对象内部的 len。&lt;/p&gt;

&lt;p&gt;当以上代码应用 &lt;code class=&quot;highlighter-rouge&quot;&gt;MPX&lt;/code&gt; 之后的代码为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndmk&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;79&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// Make bounds [a, a+79]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;bndcl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// Lower-bound check of a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;bndcu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// Upper-bound check of a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;objptr_b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bndldx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// Bounds for pointer at a[i]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;bndcl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Lower-bound check of obj.len&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;bndcu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objptr_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Upper-bound check of obj.len&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lenptr&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先，&lt;code class=&quot;highlighter-rouge&quot;&gt;a[10]&lt;/code&gt; 的界限 bounds 在第2行创建（由于这个数组有10个指针，且每个指针的大小为8 bytes，所以上限为 79），然后在第 8 行读入数组中值之前进行边界检查，2个边界检查的命令插入到 load 之前（第6-7行），从而预防 overflow ，注意：由于我们保护的数据大小为8（因为 ai 中的值是个指针），所以上界检查为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ai+7&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这时指向对象 obj 的指针加载到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt;，那么程序的下一步是要读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj.len&lt;/code&gt; 。根据设计 MPX 也需要保护这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的读写。那么这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的界限怎么得到呢？在 MPX 设计中每个存在内存中的指针都有与之对应的 bounds 存储在一个特定的内存位置（后面会讲到），并且可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndstx&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; 指令来获取。所以当从 &lt;code class=&quot;highlighter-rouge&quot;&gt;ai&lt;/code&gt; 获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的时候， &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的界限也使用指令 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ai&lt;/code&gt; 来获取(第9行). 最后，在读入 len 之前也需要界限检查（第11-12行）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里得到 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr&lt;/code&gt; 的界限是通过  &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr 在内存的地址（如 ai）&lt;/code&gt;，而不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;objptr 所指向的地址（如 objptr 的值）&lt;/code&gt; 来获取的。&lt;/p&gt;

&lt;p&gt;为了实现上述的 MPX 需要在以下各层作出修改：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;hardware level&lt;/code&gt; : 添加一系列 128-bits 寄存器，和相应的指令支持，以及通过指令抛 &lt;code class=&quot;highlighter-rouge&quot;&gt;#BR exception&lt;/code&gt; 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;OS level&lt;/code&gt; : 实现  &lt;code class=&quot;highlighter-rouge&quot;&gt;#BR exception handler&lt;/code&gt; ; 主要是实现两个函数：（1）按需存储界限；（2）当发生界限检查发现出界的情况向用户程序发送相应的信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compiler level&lt;/code&gt; 需要添加 MPX 转换 pass，用于插入 MPX 指令来 create、propagate、store 界限，和界限检查。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文主要翻译介绍 &lt;code class=&quot;highlighter-rouge&quot;&gt;hardware level&lt;/code&gt; 的实现，对于其他层的介绍可以阅读参考链接阅读&lt;a href=&quot;https://intel-mpx.github.io/design/&quot;&gt;原文&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;二-hardware&quot;&gt;（二）、 Hardware&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Intel MPX 提供了 7 个新的指令和一系列 128-bits 寄存器。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Skylake&lt;/code&gt; 架构中提供的 4 个寄存器是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd0-bnd3&lt;/code&gt;；每个寄存器的低 64 位存储的是边界的下界，高64位存储的是边界的上界。&lt;/p&gt;

&lt;p&gt;新添加的指令是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndmk&lt;/code&gt; : 创建新的界限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndcl&lt;/code&gt; : 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPR&lt;/code&gt;(general-purpos register) 中指针的值和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 中的界限的下界进行比较。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndcu&lt;/code&gt; : 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPR&lt;/code&gt;(general-purpos register) 中指针的值和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 中的界限的上界进行比较。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndcn&lt;/code&gt; : 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndcu&lt;/code&gt; 的互补形式，效果一样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndmov&lt;/code&gt; : 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 寄存器中的值从一个寄存器移动到另一个寄存器，并存入到栈上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; : 从 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;ounds &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;ables 中加载界限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bndstx&lt;/code&gt; : 存储界限到 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;ounds &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;ables 中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时 MPX 还更改了x86-64 的函数调用部分，把参数中的指针界限存入到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd0-bnd3&lt;/code&gt; , 函数返回前，当返回值为指针，则把该指针的界限保存到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd0&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;对于界限检查使用硬件实现和软件方式相比优势是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;MPX 新引入了寄存器，从而减少 GPR(general-purpos register) 的负担。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于软件实现方案不能更改函数调用，所以只能使用 function copy, 当参数中函数指针的时候，把指针相应的界限加入到参数中，从而使得参数变得太多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;性能问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MPX 有个很好的特性就是向前兼容，MPX 程序能够运行在老的不支持 MPX 的机器上，因为 MPX 指令在老机器上为 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOP&lt;/code&gt; 指令。同时支持 MPX 的机器能够运行之前的老代码，因为：（1）有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;BNDPRESERVE&lt;/code&gt; 位来设置指针没有界限信息；（2）在老代码中，出现对内存中指针的更改的话，那么下一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt; 的话会知道这个更改，并把界限设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;INIT&lt;/code&gt; 也就是没有界限限制。所以根据以上两点使得在 create 、altered 指针时都能够得到无界限限制的指针，所以便于解决兼容问题。&lt;/p&gt;

&lt;h4 id=&quot;storing-bounds-in-memory&quot;&gt;Storing bounds in memory&lt;/h4&gt;

&lt;p&gt;由于 MPX 只有 4 个 &lt;code class=&quot;highlighter-rouge&quot;&gt;bnd&lt;/code&gt; 寄存器，这显然是不够的，所以当需要存储的界限超过 4 时需要把界限存储到内存中。一个简单快速的方法为：直接把界限通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndmov&lt;/code&gt; 复制到编译器指定的内存位置 stack。但是，以上方法只能把界限存储到单一的 stack frame 上，如果别的函数还用到这个指针的话将得不到相应的界限。为了解决这个问题，引入了两个新的指令 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndstx&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bndldx&lt;/code&gt;，这两个指令会 store/load 界限到内存，那么存储到内存的什么位置呢？这个位置是根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;指针的位置&lt;/code&gt; 计算出来的（注意：是指针的位置而不是指针的值）。所以不需要额外的信息就可以得到指针对应的界限。&lt;/p&gt;

&lt;p&gt;如何根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;指针的位置&lt;/code&gt; 计算出指针对应的界限呢？&lt;/p&gt;

&lt;p&gt;做法是通过两级地址翻译的过程，其实该做法和页表非常相似。每个指针在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table (BT)&lt;/code&gt; 中都有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt; 与之对应，该  &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt; 的大小为 128-bits 内容为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LBound&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UBound&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pointer&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Preserved&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中， &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt; 是存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table (BT)&lt;/code&gt; 的，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table (BT)&lt;/code&gt; 的基址是存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Directory (BD)&lt;/code&gt; 中的。这和 Paging 非常相似：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table Entry&lt;/code&gt;  $\to$ &lt;code class=&quot;highlighter-rouge&quot;&gt;Page Table Entry&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Table&lt;/code&gt;  $\to$ &lt;code class=&quot;highlighter-rouge&quot;&gt;Page Table&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bounds Directory&lt;/code&gt;  $\to$ &lt;code class=&quot;highlighter-rouge&quot;&gt;PageDirectory&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;翻译过程如下图所以：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/image/MPX/mpx.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先，需要找到 BD entry：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;1）把指针的地址中第 20-47 位左移 3 位（因为 BD entry 的大小位 $2^3$ ）来获取  BD entry 在 BD 中的偏移量。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;2）从 &lt;code class=&quot;highlighter-rouge&quot;&gt;BNDCFGx&lt;/code&gt; 寄存器中获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;BD 基址&lt;/code&gt; （其中：&lt;code class=&quot;highlighter-rouge&quot;&gt;BNDCFGU&lt;/code&gt; 对应用户态的，&lt;code class=&quot;highlighter-rouge&quot;&gt;BNDCFGS&lt;/code&gt; 对应内核态）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;3）把基址和偏移量相加从而得到 BD entry。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其次，需要找到 BT entry：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;4）把指针的地址中第 3-19 位左移 5 位（因为 BT entry 的大小位 $2^5$ ）来获取  BT entry 在 BT 中的偏移量。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;5）把上一步获取的 BD entry右移 3 位（用于删除前 3 位包含的 metadata）来获取  BT 基址。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;6）把基址和偏移量相加从而得到 BT entry。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;7）Load BT entry。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：在 BT entry 中存储了指针的值，其用处是每次找到这个 BT entry 后需要把指针值和 BT entry中的指针值进行比较，如果不相等则默认这个指针的界限为 &lt;code class=&quot;highlighter-rouge&quot;&gt;INIT&lt;/code&gt; ，主要用于兼容性考虑。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;三参考&quot;&gt;（三）、参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://intel-mpx.github.io/design/&quot;&gt;https://intel-mpx.github.io/design/&lt;/a&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文主要简单介绍 MPX</summary></entry><entry><title type="html">SSA Form and PHI Nodes</title><link href="http://localhost:4000/llvm/tech/2019/02/14/ssa-form-and-phi-nodes.html" rel="alternate" type="text/html" title="SSA Form and PHI Nodes" /><published>2019-02-14T20:26:29+08:00</published><updated>2019-02-14T20:26:29+08:00</updated><id>http://localhost:4000/llvm/tech/2019/02/14/ssa-form-and-phi-nodes</id><content type="html" xml:base="http://localhost:4000/llvm/tech/2019/02/14/ssa-form-and-phi-nodes.html">&lt;p&gt;本文主要简单介绍 LLVM 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHINode&lt;/code&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;最近接触到追踪一个变量在程序中的使用。当对 LLVM IR 中 instruction 进行分析的时候，遇到类似如下的代码：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;%19&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%entry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%land.rhs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该指令为 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHINode&lt;/code&gt;，为 llvm 中的一个指令类，继承于 &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm::Instruction&lt;/code&gt;，具体继承关系和 llvm 源码见：&lt;a href=&quot;https://llvm.org/doxygen/classllvm_1_1PHINode.html&quot;&gt;PHINode 类&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;一ssa-简介&quot;&gt;（一）、SSA 简介&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
在正式介绍 PHI Nodes 之前首先需要了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSA&lt;/code&gt; ，因为所有的 LLVM IR 指令都是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSA&lt;/code&gt; 形式表示。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;1ssa&quot;&gt;（1）、SSA&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SSA (static single assignment form)&lt;/code&gt; ：&lt;strong&gt;静态一次性赋值&lt;/strong&gt;；意思是说&lt;strong&gt;每个变量（虚拟寄存器）都只能被赋值一次&lt;/strong&gt;；这样做的好处是可以方便优化代码。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nl&quot;&gt;y :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;y :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;x :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;显然，在以上代码中我们能够一眼看出第一行代码是多余的，因为在第三行使用的 $y$ 的值是来自第二行对 $y$ 的赋值，而不是来自第一行对 $y$ 的赋值。而对于程序来说并不能直观的得出第一行是多余的，需要做数据流分析才能判断第一行是多余的。$SSA$ 恰好能够解决该问题，以上代码用 $SSA$ 形式来表示的话：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nl&quot;&gt;y1 :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;y2 :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;x1 :&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;很明显，用以上表示方法程序不需要做数据流分析就能够知道第三行使用的 $y$ 是来自第二行的定义。当然，使用 $SSA$ 还能做很多别的优化，我也没有细看，这里就不再赘述了，有兴趣的话可以参考：&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single_assignment_form&quot;&gt;维基百科上的介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;2生成-ssa-形式的指令&quot;&gt;（2）、生成 SSA 形式的指令&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;
我们可以通过探究 $SSA$ 指令的生成知道为什么要引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI Nodes&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;把一个普通程序转化为 $SSA$ 形式，最简单的做法就是把每一次的赋值都赋值给一个新的变量（或者说是同一个变量的不同版本），同时在使用变量的时候，使用能够到达该程序点对应的”版本”。
举个例子，在下图的控制流图中，左边图一是原程序流图，右图为按照上述方法生成的 SSA 形式的程序流图。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;图一：原程序流图&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;图二：SSA 形式流图（中间版本）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/7/73/SSA_example1.1.png&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/f/f7/SSA_example1.2.png&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们可以发现在右图最底下的基本块中，对于 $y$ 的使用可能来自 $y_1$ 也可能来自 $y_2$，取决于程序是从哪条路径到达该程序点的。为了解决该问题，引入了一条新的语句：$\phi$，该语句会生成一个新的 $y$ 的定义 $y_3$，$y_3$ 的值会根据控制流是从哪条路径到达而选择不同的值 $y_1$ 或 $y_2$:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;图三：SSA 形式流图&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/84/SSA_example1.3.png&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上述的 $\phi$ 函数就是我们所要介绍的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI Node&lt;/code&gt;。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
$ y_3 \leftarrow \phi (y_1, y_2) $
&lt;/p&gt;
&lt;p&gt;PHI node 根据控制流是从哪一个 block ( $y_1\leftarrow x_2 * 2$ 或 $y_2\leftarrow x_2 -3$) 到达，来决定使用 $y_1$ 或 $y_2$ 赋值给 $y_3$。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;二phi-nodes-简介&quot;&gt;（二）、PHI Nodes 简介&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
在上一节中我们已经介绍了为什么要引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI Nodes&lt;/code&gt;；本节主要通过一个例子来讲解 PHI Nodes。&lt;/p&gt;

&lt;p&gt;回顾一下 PHI Nodes：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;PHI Nodes 会记录是从哪个 control-flow 过来的，从而使用相应的值（类似多路复用器）。&lt;/li&gt;
    &lt;li&gt;并没有实际实现，只是编译器会保证相应的 virtual registers 映射到了同一个 physical register。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，以下左图为原程序，右图为相应的 control-flow。
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/LLVM/PHINode/phinode_no_ssa.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
当引入 SSA 形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/LLVM/PHINode/phinode_ssa.png&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
对于一个 PHI node 可以表示为：&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%result = phi i32 [value1, BB label1], [value2, BB label2]&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;当从 label1 所对应的 basic block(BB) 路径到达 PHI node, 则 result 的值为 value1; 同理,当从 label2 所对应的 basic block路径到达 PHI node, 则 result 的值为 value2。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;三参考链接&quot;&gt;（三）、参考链接&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;http://www.llvmpy.org/llvmpy-doc/dev/doc/llvm_concepts.html#ssa-form-and-phi-nodes&quot;&gt;http://www.llvmpy.org/llvmpy-doc/dev/doc/llvm_concepts.html#ssa-form-and-phi-nodes&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single_assignment_form&quot;&gt;https://en.wikipedia.org/wiki/Static_single_assignment_form&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://cs.uni-paderborn.de/fileadmin/informatik/fg/hit/teaching/SS2017/HWSW-Codesign/02-Compiler-LLVM.pdf&quot;&gt;https://cs.uni-paderborn.de/fileadmin/informatik/fg/hit/teaching/SS2017/HWSW-Codesign/02-Compiler-LLVM.pdf&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://llvm.org/doxygen/classllvm_1_1PHINode.html&quot;&gt;https://llvm.org/doxygen/classllvm_1_1PHINode.html&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">本文主要简单介绍 LLVM 中的 PHINode。</summary></entry><entry><title type="html">Test for blogging</title><link href="http://localhost:4000/jekyll/tech/2019/02/07/test-for-blogging.html" rel="alternate" type="text/html" title="Test for blogging" /><published>2019-02-07T12:55:13+08:00</published><updated>2019-02-07T12:55:13+08:00</updated><id>http://localhost:4000/jekyll/tech/2019/02/07/test-for-blogging</id><content type="html" xml:base="http://localhost:4000/jekyll/tech/2019/02/07/test-for-blogging.html">&lt;p&gt;该文用于说明写 blog 的一些格式要求。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建-blog&quot;&gt;新建 blog&lt;/h3&gt;

&lt;p&gt;当需要创建一个新的 blog 时(假设名字为：Test for blogging), 在 blog 的主目录中输入以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopress new post Test for blogging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该命令会在文件夹 &lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt; 中生成文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;2019-02-07-test-for-blogging.markdown&lt;/code&gt;, 文件名前面的时间是自动添加的，编辑该文件为以下格式：&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;layout: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;title: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Test for blogging&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;date: &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2019&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;07&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;08&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;categories: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Jekyll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Tech&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;author: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cdz&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;excerpt_separator: &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;这里编写&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blog&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;正文。中间可以用&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;!--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;分割。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;: 表示该 blog 属于哪个 layout，不同的 layout 会有不同的显示，具体显示的格式规定在文件夹 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt; 中，当为 &lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt; 时表示按照 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts/post.html&lt;/code&gt; 的格式显示。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;: 表示该 blog 的生成时间，是自动生成的。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;categories&lt;/code&gt;: 表示该 blog 属于那一类，可以自己定义，当属于多个类的时候需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;[category1, category2 ]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;author&lt;/code&gt;: 表示该 blog 的博主。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;excerpt_separator: &amp;lt;!--more--&amp;gt;&lt;/code&gt;: 表示在该 blog 中使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 分割， &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 的前一半内容会显示在home中的预览中，后一半只有点进博客才能看到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里是插入网址的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 格式为：[文中显示内容][网页地址记号]
// 在文本的最后：[网页地址记号]：网页地址
[CDZ's Blog][cdz-blog]

[cdz-blog]: https://blog.dianzhangchen.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;预览-blog&quot;&gt;预览 blog&lt;/h3&gt;

&lt;p&gt;在主目录中输入：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build
jekyll serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时候在浏览器中输入：&lt;a href=&quot;http://localhost:4000/&quot;&gt;http://localhost:4000/&lt;/a&gt; 就可以去看效果。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;部署-blog-到网站&quot;&gt;部署 blog 到网站&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopress deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写-markdown-的一些技巧&quot;&gt;编写 markdown 的一些技巧&lt;/h3&gt;

&lt;h4 id=&quot;1插入空行&quot;&gt;(1)、插入空行&lt;/h4&gt;

&lt;p&gt;插入空行使用 html 的语法，只需要在相应的位置插入 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br/&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;2插入图片&quot;&gt;(2)、插入图片&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![image-title-here](/path/to/image.jpg){:class=&quot;img-responsive&quot;}

// 或者按照以下方法，使用 html 语法, 可以调节图片的大小
&amp;lt;p&amp;gt;&amp;lt;img src=&quot;/image/DongBei/barbecue.jpg&quot; width=&quot;500&quot;&amp;gt;&amp;lt;/p&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一种方法效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/test/icon.ico&quot; alt=&quot;test_image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二种方法效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/test/icon.ico&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html">该文用于说明写 blog 的一些格式要求。</summary></entry><entry><title type="html">在东北</title><link href="http://localhost:4000/life/travel/2019/02/07/md.html" rel="alternate" type="text/html" title="在东北" /><published>2019-02-07T10:26:57+08:00</published><updated>2019-02-07T10:26:57+08:00</updated><id>http://localhost:4000/life/travel/2019/02/07/md</id><content type="html" xml:base="http://localhost:4000/life/travel/2019/02/07/md.html">&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/image/DongBei/snow_train.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;扬帆&quot;&gt;扬帆&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;今年上海的雪下得吊人胃口，虽说来的早，可落地即化，未免有点失望。&lt;br /&gt;
对于南方人，能在冬天看看雪，吃点冰块就很幸福了。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;要不要一起去东北玩？ &lt;br /&gt;
妥！！！&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;出发前对于东北充满好奇。&lt;br /&gt;
零下20度是什么概念？&lt;br /&gt;
一出山海关，都是赵本山？&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;接着就是各种准备。加厚棉袜，手套，雪地靴，雷锋帽，暖宝宝。&lt;br /&gt;
出于对零下20度的敬畏，线上线下一顿忙活。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;奉天&quot;&gt;奉天&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
到沈阳，住进宾馆，已是傍晚。&lt;br /&gt;
随后就在中街溜达，刚开始去了个假的中街。&lt;br /&gt;
一行人就感叹，怎么着也是个省会城市的最有名的步行街，怎么能这么小？&lt;br /&gt;
失望的找地铁站回家途中，走到了真正的中街，豁然开朗。&lt;br /&gt;
它拥有了一个步行街该有的繁华，绚丽。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不得不说，东北的暖气是神一般的存在。&lt;br /&gt;
当晚在宾馆，热得飞起。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;第二天就去了沈阳冰雪大世界，各种游乐项目：冰上碰碰车，雪摩托，雪地飞狐。&lt;br /&gt;
最刺激的还是冰滑道：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/shenyang_ski.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;泡澡&quot;&gt;泡澡&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;刚开始提出去泡澡计划，我想都没想就拒绝了。&lt;br /&gt;
之后被各种安利，想想东北特色的洗澡文化，来都来了，不体验一把还是有点遗憾的。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;这边泡澡基本流程就是：冲、泡、搓、蒸、冲。&lt;br /&gt;
搓澡的时候会有各种选择，有红酒搓，醋搓；红酒搓听起来就x格高，自然就选了这个。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在一个类似火车卧铺的床位上加上一层一次性桌布，往上一躺。&lt;br /&gt;
搓澡师当面开封一个新的搓澡巾, 然后就卡卡搓上了。&lt;br /&gt;
变搓边唠嗑，东北话自带幽默属性。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;想体验东北文化，就得整全套的。&lt;br /&gt;
搓澡之后的烧烤是必须的，东北澡堂周边必有烧烤店。&lt;br /&gt;
几盘烧烤，一瓶啤酒，甚是满足。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/DongBei/barbecue.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;哈尔滨&quot;&gt;哈尔滨&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;哈尔滨就更冷了，拿手机拍照都需要很大的勇气。&lt;br /&gt;
一是，拍照需要摘下手套，又冷又麻烦。&lt;br /&gt;
再者，手机用电很快，且容易冻关机。&lt;br /&gt;
在风大的地方，很多人是倒退走路的：&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/walk_backward.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
在这可以看到浓郁俄罗斯风情的中央大街，随处可听到 “喀秋莎”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/central_street.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
在中央大街附近还有索菲亚大教堂，是一个拜占庭风格的教堂，据说是沙俄第四步兵师修建中东铁路时修建的一座随军教堂。&lt;br /&gt;
夜晚的教堂气宇轩昂。&lt;br /&gt;
同行的一小伙，硬是拿着 GoPro 绕着教堂跑了一圈。&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/church.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;滑雪&quot;&gt;滑雪&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;早上5点多起来坐车去，亚布力滑雪场。&lt;br /&gt;
在中途休息站能看到很有东北特色的小贩。&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/shop.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;滑雪之前还是被忽悠加了一些别的项目，马拉犁、冰滑道、等一些热门娱乐。&lt;br /&gt;
马拉着一车人，在雪地里“飞驰”。&lt;br /&gt;
同车的一大叔开玩笑道：“这马不给力啊，别弄的我们都得下去推车了”。&amp;gt;_&amp;lt;||| &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/malali2.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;也终于到了滑雪的时候。&lt;br /&gt;
曾听说滑雪是白色鸦片，第一次接触滑雪的人，要么从此别过，要么就沾上这个“鸦片”。&lt;br /&gt;
我们滑雪前都定了一个小目标：能够独立缓慢滑行。&lt;br /&gt;
由于我们都有穷病就没有请教练 &amp;gt;_&amp;lt;|||&lt;br /&gt;
刚开始的时候，五米一小摔倒，十米一大摔。&lt;br /&gt;
幸得滑雪场旁边一大爷给我指点，后面摔倒明显减少，就算摔也比之前摔的有尊严一点。&lt;br /&gt;
我感觉滑雪和开车也有相似之处，滑的时候不要盯着脚下，要看前方。&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/DongBei/ski2.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;松花江&quot;&gt;松花江&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;松花江上结了一层厚冰，上面堆满了雪人，这得有多少人对雪爱的深沉&lt;br /&gt;
我们决定冰面上横跨松花江。&lt;br /&gt;
一行人，围巾遮面，低头避风就缓慢出发了。&lt;br /&gt;
走到松花江中间，环顾四周，突感大自然的神奇，一条活动的江水居然能够结冰，且如此结实。&lt;br /&gt;
由于不敢和寒风正面刚，本来应该垂直跨过松花江，硬生生走出了一条大斜线。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/DongBei/snow_man.jpg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;吃&quot;&gt;吃&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在东北吃的最感人的就属冰糖葫芦了，五块钱一串，冰冰的、酸酸的、甜甜的，甚是可口。&lt;br /&gt;
这让我想起霸王别姬中的桥段，一小孩在自杀之前最后的愿望就是吃冰糖葫芦。&lt;br /&gt;
回上海之前，还特意早起去马迭尔买了几串冰糖葫芦带回来。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;其它的特色食物就是：红菜汤，锅包肉，老太太烧烤，烤冷面，秋林红肠；除了老太太烧烤有点失望外，其余都还算满意。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;后面，还特意去了趟哈尔滨工业大学，感受一波北方大学的建筑风格。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;“世界不是苟且，世界是远方，行万里路才能回到内心深处；未来不是岁数，未来是谜雾，读万卷书才能看清皓月繁星。” &lt;br /&gt;
好好学习，好好工作，赚够旅游的盘缠。&lt;br /&gt;&lt;/p&gt;</content><author><name>cdz</name></author><summary type="html"></summary></entry></feed>