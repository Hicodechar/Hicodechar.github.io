<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>MPX | CDZ</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="MPX" />
<meta name="author" content="cdz" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文主要简单介绍 MPX" />
<meta property="og:description" content="本文主要简单介绍 MPX" />
<link rel="canonical" href="blog.dianzhangchen.com/tech/2019/02/17/mpx.html" />
<meta property="og:url" content="blog.dianzhangchen.com/tech/2019/02/17/mpx.html" />
<meta property="og:site_name" content="CDZ" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-02-17T01:33:43+08:00" />
<script type="application/ld+json">
{"description":"本文主要简单介绍 MPX","author":{"@type":"Person","name":"cdz"},"@type":"BlogPosting","url":"blog.dianzhangchen.com/tech/2019/02/17/mpx.html","headline":"MPX","dateModified":"2019-02-17T01:33:43+08:00","datePublished":"2019-02-17T01:33:43+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"blog.dianzhangchen.com/tech/2019/02/17/mpx.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="blog.dianzhangchen.com/feed.xml" title="CDZ" /><!-- [cdz]: 为了 markdown 数学公式 -->
  <!-- 参考：
  https://weilai5432.github.io/2017/01/11/MathJax-%E5%9C%A8MarkDown%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/ -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        <!--$表示行内元素，$$表示块状元素 -->
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
  <!--加载MathJax的最新文件， async表示异步加载进来 -->
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js">
  </script>

<!-- <script color="0,0,0" opacity="0.5" count="99" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.js" type="text/javascript" charset="utf-8"></script> -->

</head>
<body>

    <!-- <script color="0,0,0" opacity="0.5" count="99" src="/my_script/particles.min.js" type="text/javascript" charset="utf-8"></script> -->
    <!-- [cdz]: 动画 -->
    <!-- <div id="particles-js"></div>
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <script>
      /* particlesJS.load(@dom-id, @path-json, @callback (optional)); */
      particlesJS.load('particles-js', '/my_json/particles.json', function() {
      console.log('callback - particles.js config loaded');
      });
    </script> -->
    <!-- <script color="0,133,255" opacity="0.8" count="180" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.js" type="text/javascript"></script> -->
    <!-- <script color="0,133,255" opacity="0.8" count="180" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.js" type="text/javascript" charset="utf-8"></script> -->
    <!-- <script src="https://www.supertechcrew.com/assets/js/main.min.js"></script> --><header class="site-header" role="banner">
  


  <div class="wrapper">
    <!-- <script color="0,0,0" opacity="0.5" count="99" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.js" type="text/javascript" charset="utf-8"></script> -->
    <!-- [cdz]: 添加以下一行用于给 pages 排序，排序规则按照 page 中的 order 属性排序 -->
    <!-- [cdz]: 参考网址：https://stackoverflow.com/questions/13266369/how-to-change-the-default-order-pages-in-jekyll --><a class="site-title" rel="author" href="/">CDZ</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <!-- <div class="trigger"><a class="page-link" href="/">Home</a><a class="page-link" href="/archive/">Archive</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/Tech"></a><a class="page-link" href="/categories/Life"></a><a class="page-link" href="/categories/Travel.html"></a><a class="page-link" href="/categories/Jekyll"></a><a class="page-link" href="/categories/LLVM"></a></div> -->

        <div class="trigger"><a class="page-link" href="/">Home</a><a class="page-link" href="/archive/">Archive</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/Tech"></a><a class="page-link" href="/categories/Life"></a><a class="page-link" href="/categories/Travel.html"></a><a class="page-link" href="/categories/Jekyll"></a><a class="page-link" href="/categories/LLVM"></a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="post-categories" align="right">
  
  
  <a href="/categories/Tech">Tech</a>
  
  
</div>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"> 
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">MPX</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-02-17T01:33:43+08:00" itemprop="datePublished">Feb 17, 2019
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">cdz</span></span></p>
  </header>




  <div class="post-content e-content" itemprop="articleBody">
    <p>本文主要简单介绍 MPX</p>

<!--more-->

<p><br /></p>
<h3 id="一mpx-简介">（一）、MPX 简介</h3>
<hr />
<p><br /></p>

<p><code class="highlighter-rouge">Intel Memory Protection Extensions</code> (Intel <code class="highlighter-rouge">MPX</code>)  首次是在 2013 年提出，并在2015年引入到 Intel 的第六代处理器 Skylake. MPX 的目的是为 C/C++ 加入 bounds check 机制，从而保证内存安全。首先，看一下以下代码片段：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
   <span class="k">struct</span> <span class="n">obj</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>  <span class="kt">int</span> <span class="n">len</span> <span class="p">}</span>
<span class="mi">1</span><span class="o">:</span> <span class="n">obj</span><span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>                      <span class="c1">// Array of pointers to objs</span>
<span class="mi">2</span><span class="o">:</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="mi">3</span><span class="o">:</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="o">:</span>
<span class="mi">4</span><span class="o">:</span>     <span class="n">ai</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span>                  <span class="c1">// Pointer arithmetic on a</span>
<span class="mi">5</span><span class="o">:</span>     <span class="n">objptr</span> <span class="o">=</span> <span class="n">load</span> <span class="n">ai</span>            <span class="c1">// Pointer to obj at a[i]</span>
<span class="mi">6</span><span class="o">:</span>     <span class="n">lenptr</span> <span class="o">=</span> <span class="n">objptr</span> <span class="o">+</span> <span class="mi">100</span>       <span class="c1">// Pointer to obj.len</span>
<span class="mi">7</span><span class="o">:</span>     <span class="n">len</span> <span class="o">=</span> <span class="n">load</span> <span class="n">lenptr</span>
<span class="mi">8</span><span class="o">:</span>     <span class="n">total</span> <span class="o">+=</span> <span class="n">len</span>                <span class="c1">// Total length of all objs</span>
</code></pre></div></div>

<p>以上程序分配了一个数组 <code class="highlighter-rouge">a[10]</code> 的指针, 也就是10个指针，每个指针都指向类型为 <code class="highlighter-rouge">obj</code> 的对象，然后遍历前 M 个对象，把其中的 len 值相加得到总的len值（3-8行）total 。以上代码对应的 C 语言形式为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">total</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意：<code class="highlighter-rouge">ai</code> 是表示 <code class="highlighter-rouge">a[i]</code> 的<code class="highlighter-rouge">指针</code>，同时需要注意 <code class="highlighter-rouge">lenptr</code> 如何指向对象内部的 len。</p>

<p>当以上代码应用 <code class="highlighter-rouge">MPX</code> 之后的代码为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="mi">1</span><span class="o">:</span> <span class="n">obj</span><span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="mi">2</span><span class="o">:</span> <span class="n">a_b</span> <span class="o">=</span> <span class="n">bndmk</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">79</span>          <span class="c1">// Make bounds [a, a+79]</span>
<span class="mi">3</span><span class="o">:</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="mi">4</span><span class="o">:</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="o">:</span>
<span class="mi">5</span><span class="o">:</span>     <span class="n">ai</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span>
<span class="mi">6</span><span class="o">:</span>     <span class="n">bndcl</span> <span class="n">a_b</span><span class="p">,</span> <span class="n">ai</span>            <span class="c1">// Lower-bound check of a[i]</span>
<span class="mi">7</span><span class="o">:</span>     <span class="n">bndcu</span> <span class="n">a_b</span><span class="p">,</span> <span class="n">ai</span><span class="o">+</span><span class="mi">7</span>          <span class="c1">// Upper-bound check of a[i]</span>
<span class="mi">8</span><span class="o">:</span>     <span class="n">objptr</span> <span class="o">=</span> <span class="n">load</span> <span class="n">ai</span>
<span class="mi">9</span><span class="o">:</span>     <span class="n">objptr_b</span> <span class="o">=</span> <span class="n">bndldx</span> <span class="n">ai</span>     <span class="c1">// Bounds for pointer at a[i]</span>
<span class="mi">10</span><span class="o">:</span>    <span class="n">lenptr</span> <span class="o">=</span> <span class="n">objptr</span> <span class="o">+</span> <span class="mi">100</span>
<span class="mi">11</span><span class="o">:</span>    <span class="n">bndcl</span> <span class="n">objptr_b</span><span class="p">,</span> <span class="n">lenptr</span>   <span class="c1">// Lower-bound check of obj.len</span>
<span class="mi">12</span><span class="o">:</span>    <span class="n">bndcu</span> <span class="n">objptr_b</span><span class="p">,</span> <span class="n">lenptr</span><span class="o">+</span><span class="mi">3</span> <span class="c1">// Upper-bound check of obj.len</span>
<span class="mi">13</span><span class="o">:</span>    <span class="n">len</span> <span class="o">=</span> <span class="n">load</span> <span class="n">lenptr</span>
<span class="mi">14</span><span class="o">:</span>    <span class="n">total</span> <span class="o">+=</span> <span class="n">len</span>
</code></pre></div></div>

<p>首先，<code class="highlighter-rouge">a[10]</code> 的界限 bounds 在第2行创建（由于这个数组有10个指针，且每个指针的大小为8 bytes，所以上限为 79），然后在第 8 行读入数组中值之前进行边界检查，2个边界检查的命令插入到 load 之前（第6-7行），从而预防 overflow ，注意：由于我们保护的数据大小为8（因为 ai 中的值是个指针），所以上界检查为 <code class="highlighter-rouge">ai+7</code>。</p>

<p>这时指向对象 obj 的指针加载到了 <code class="highlighter-rouge">objptr</code>，那么程序的下一步是要读取 <code class="highlighter-rouge">obj.len</code> 。根据设计 MPX 也需要保护这个 <code class="highlighter-rouge">objptr</code> 的读写。那么这个 <code class="highlighter-rouge">objptr</code> 的界限怎么得到呢？在 MPX 设计中每个存在内存中的指针都有与之对应的 bounds 存储在一个特定的内存位置（后面会讲到），并且可以通过 <code class="highlighter-rouge">bndstx</code> 和 <code class="highlighter-rouge">bndldx</code> 指令来获取。所以当从 <code class="highlighter-rouge">ai</code> 获取 <code class="highlighter-rouge">objptr</code> 的时候， <code class="highlighter-rouge">objptr</code> 的界限也使用指令 <code class="highlighter-rouge">bndldx</code> 通过 <code class="highlighter-rouge">ai</code> 来获取(第9行). 最后，在读入 len 之前也需要界限检查（第11-12行）。</p>

<p><strong>注意</strong>：这里得到 <code class="highlighter-rouge">objptr</code> 的界限是通过  <code class="highlighter-rouge">objptr 在内存的地址（如 ai）</code>，而不是 <code class="highlighter-rouge">objptr 所指向的地址（如 objptr 的值）</code> 来获取的。</p>

<p>为了实现上述的 MPX 需要在以下各层作出修改：</p>

<ul>
  <li>
    <p>在 <code class="highlighter-rouge">hardware level</code> : 添加一系列 128-bits 寄存器，和相应的指令支持，以及通过指令抛 <code class="highlighter-rouge">#BR exception</code> 。</p>
  </li>
  <li>
    <p>在 <code class="highlighter-rouge">OS level</code> : 实现  <code class="highlighter-rouge">#BR exception handler</code> ; 主要是实现两个函数：（1）按需存储界限；（2）当发生界限检查发现出界的情况向用户程序发送相应的信号。</p>
  </li>
  <li>
    <p>在 <code class="highlighter-rouge">Compiler level</code> 需要添加 MPX 转换 pass，用于插入 MPX 指令来 create、propagate、store 界限，和界限检查。</p>
  </li>
</ul>

<p>本文主要翻译介绍 <code class="highlighter-rouge">hardware level</code> 的实现，对于其他层的介绍可以阅读参考链接阅读<a href="https://intel-mpx.github.io/design/">原文</a>。</p>

<p><br /></p>
<h3 id="二-hardware">（二）、 Hardware</h3>
<hr />
<p><br /></p>

<p>Intel MPX 提供了 7 个新的指令和一系列 128-bits 寄存器。在 <code class="highlighter-rouge">Skylake</code> 架构中提供的 4 个寄存器是 <code class="highlighter-rouge">bnd0-bnd3</code>；每个寄存器的低 64 位存储的是边界的下界，高64位存储的是边界的上界。</p>

<p>新添加的指令是：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">bndmk</code> : 创建新的界限。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">bndcl</code> : 把 <code class="highlighter-rouge">GPR</code>(general-purpos register) 中指针的值和 <code class="highlighter-rouge">bnd</code> 中的界限的下界进行比较。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">bndcu</code> : 把 <code class="highlighter-rouge">GPR</code>(general-purpos register) 中指针的值和 <code class="highlighter-rouge">bnd</code> 中的界限的上界进行比较。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">bndcn</code> : 是 <code class="highlighter-rouge">bndcu</code> 的互补形式，效果一样。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">bndmov</code> : 把 <code class="highlighter-rouge">bnd</code> 寄存器中的值从一个寄存器移动到另一个寄存器，并存入到栈上。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">bndldx</code> : 从 <code class="highlighter-rouge">B</code>ounds <code class="highlighter-rouge">T</code>ables 中加载界限。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">bndstx</code> : 存储界限到 <code class="highlighter-rouge">B</code>ounds <code class="highlighter-rouge">T</code>ables 中。</p>
  </li>
</ul>

<p>同时 MPX 还更改了x86-64 的函数调用部分，把参数中的指针界限存入到 <code class="highlighter-rouge">bnd0-bnd3</code> , 函数返回前，当返回值为指针，则把该指针的界限保存到 <code class="highlighter-rouge">bnd0</code> 中。</p>

<p>对于界限检查使用硬件实现和软件方式相比优势是：</p>

<ul>
  <li>
    <p>MPX 新引入了寄存器，从而减少 GPR(general-purpos register) 的负担。</p>
  </li>
  <li>
    <p>由于软件实现方案不能更改函数调用，所以只能使用 function copy, 当参数中函数指针的时候，把指针相应的界限加入到参数中，从而使得参数变得太多。</p>
  </li>
  <li>
    <p>性能问题。</p>
  </li>
</ul>

<p>MPX 有个很好的特性就是向前兼容，MPX 程序能够运行在老的不支持 MPX 的机器上，因为 MPX 指令在老机器上为 <code class="highlighter-rouge">NOP</code> 指令。同时支持 MPX 的机器能够运行之前的老代码，因为：（1）有一个 <code class="highlighter-rouge">BNDPRESERVE</code> 位来设置指针没有界限信息；（2）在老代码中，出现对内存中指针的更改的话，那么下一次 <code class="highlighter-rouge">bndldx</code> 的话会知道这个更改，并把界限设置为 <code class="highlighter-rouge">INIT</code> 也就是没有界限限制。所以根据以上两点使得在 create 、altered 指针时都能够得到无界限限制的指针，所以便于解决兼容问题。</p>

<h4 id="storing-bounds-in-memory">Storing bounds in memory</h4>

<p>由于 MPX 只有 4 个 <code class="highlighter-rouge">bnd</code> 寄存器，这显然是不够的，所以当需要存储的界限超过 4 时需要把界限存储到内存中。一个简单快速的方法为：直接把界限通过 <code class="highlighter-rouge">bndmov</code> 复制到编译器指定的内存位置 stack。但是，以上方法只能把界限存储到单一的 stack frame 上，如果别的函数还用到这个指针的话将得不到相应的界限。为了解决这个问题，引入了两个新的指令 <code class="highlighter-rouge">bndstx</code> 和 <code class="highlighter-rouge">bndldx</code>，这两个指令会 store/load 界限到内存，那么存储到内存的什么位置呢？这个位置是根据 <code class="highlighter-rouge">指针的位置</code> 计算出来的（注意：是指针的位置而不是指针的值）。所以不需要额外的信息就可以得到指针对应的界限。</p>

<p>如何根据 <code class="highlighter-rouge">指针的位置</code> 计算出指针对应的界限呢？</p>

<p>做法是通过两级地址翻译的过程，其实该做法和页表非常相似。每个指针在 <code class="highlighter-rouge">Bounds Table (BT)</code> 中都有一个 <code class="highlighter-rouge">Bounds Table Entry</code> 与之对应，该  <code class="highlighter-rouge">Bounds Table Entry</code> 的大小为 128-bits 内容为：</p>

<ul>
  <li>
    <p>LBound</p>
  </li>
  <li>
    <p>UBound</p>
  </li>
  <li>
    <p>Pointer</p>
  </li>
  <li>
    <p>Preserved</p>
  </li>
</ul>

<p>其中， <code class="highlighter-rouge">Bounds Table Entry</code> 是存储在 <code class="highlighter-rouge">Bounds Table (BT)</code> 的，而 <code class="highlighter-rouge">Bounds Table (BT)</code> 的基址是存储在 <code class="highlighter-rouge">Bounds Directory (BD)</code> 中的。这和 Paging 非常相似：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">Bounds Table Entry</code>  $\to$ <code class="highlighter-rouge">Page Table Entry</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Bounds Table</code>  $\to$ <code class="highlighter-rouge">Page Table</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Bounds Directory</code>  $\to$ <code class="highlighter-rouge">PageDirectory</code></p>
  </li>
</ul>

<p>翻译过程如下图所以：</p>
<p align="center"><img src="/image/MPX/mpx.png" width="500" /></p>

<ul>
  <li>
    <p>首先，需要找到 BD entry：</p>

    <ul>
      <li>
        <p>1）把指针的地址中第 20-47 位左移 3 位（因为 BD entry 的大小位 $2^3$ ）来获取  BD entry 在 BD 中的偏移量。</p>
      </li>
      <li>
        <p>2）从 <code class="highlighter-rouge">BNDCFGx</code> 寄存器中获取 <code class="highlighter-rouge">BD 基址</code> （其中：<code class="highlighter-rouge">BNDCFGU</code> 对应用户态的，<code class="highlighter-rouge">BNDCFGS</code> 对应内核态）。</p>
      </li>
      <li>
        <p>3）把基址和偏移量相加从而得到 BD entry。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>其次，需要找到 BT entry：</p>

    <ul>
      <li>
        <p>4）把指针的地址中第 3-19 位左移 5 位（因为 BT entry 的大小位 $2^5$ ）来获取  BT entry 在 BT 中的偏移量。</p>
      </li>
      <li>
        <p>5）把上一步获取的 BD entry右移 3 位（用于删除前 3 位包含的 metadata）来获取  BT 基址。</p>
      </li>
      <li>
        <p>6）把基址和偏移量相加从而得到 BT entry。</p>
      </li>
      <li>
        <p>7）Load BT entry。</p>
      </li>
    </ul>
  </li>
</ul>

<p>注意：在 BT entry 中存储了指针的值，其用处是每次找到这个 BT entry 后需要把指针值和 BT entry中的指针值进行比较，如果不相等则默认这个指针的界限为 <code class="highlighter-rouge">INIT</code> ，主要用于兼容性考虑。</p>

<p><br /></p>
<h3 id="三参考">（三）、参考：</h3>

<p><a href="https://intel-mpx.github.io/design/">https://intel-mpx.github.io/design/</a></p>


  </div><a class="u-url" href="/tech/2019/02/17/mpx.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <!-- <h2 class="footer-heading">CDZ</h2> -->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">CDZ</li><li><a class="u-email" href="mailto:chendianzhang@sjtu.edu.cn">chendianzhang@sjtu.edu.cn</a></li></ul>
      </div>
      <!--以下会在 blog 最后显示一些_config.yml 中定义的一些网站的链接, 比如 GitHub 的链接-->
      <!-- <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Hicodechar"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Hicodechar</span></a></li></ul>
</div> -->
      <div class="footer-col footer-col-3">
        <p>Welcome to cdz&#39;s blog. Any questions or suggesions, please contact me.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
